<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="utf-8">
 <meta name="viewport" content="width=device-width, initial-scale=1">
 <title>Console Desktop Guide</title>
 <link href="../../css/bootstrap.min.css" rel="stylesheet">
</head>
<body>
<h2>CONSOLE DESKTOP GUIDE</h2>

<p>
<a href="images/intro.png"><img src="thumbs/intro.png" title="You can do amazing stuff with your computer these days"></a>
</p>

<h3>INDEX</h3>
<ul>
  <li><a href="#intro">What is a Console?</a></li>
  <li><a href="#serious">A Console Desktop? Seriously?!?</a></li>
  <li><a href="#basics">Basics</a></li>
  <ul>
    <li><a href="#consoles">Switching Consoles</a></li>
    <li><a href="#nvidia">Nvidia</a></li>
    <li><a href="#desktop">Getting to the Desktop again</a></li>
    <li><a href="#configuration">Configuring the Console on various Systems</a></li>
    <ul>
      <li><a href="#multi-monitor">Multiple Monitors</a></li>
      <li><a href="#linux">Linux: Generic Instructions</a></li>
      <li><a href="#framebuffer">Linux Framebuffer</a></li>
      <li><a href="#systemv">Non-System-D Linux</a></li>
      <li><a href="#systemd">System-D Linux</a></li>
      <li><a href="#nonlinux">Non-Linux Systems: A Reminder</a></li>
      <li><a href="#freebsd">FreeBSD and DragonFly BSD</a></li>
      <li><a href="#openbsd">OpenBSD</a></li>
      <li><a href="#netbsd">NetBSD</a></li>
      <li><a href="#illumos">Solaris and Illumos</a></li>
    </ul>
    <li><a href="#organize">Getting Organized</a></li>
    <li><a href="#jobs">Multitasking: Jobs</a></li>
    <li><a href="#tmux">Multitasking: Tmux</a></li>
    <li><a href="#mouse">Copy Pasting: The Console Mouse</a></li>
    <li><a href="#copy_paste_tmux">Copy Pasting: Tmux</a></li>
    <li><a href="#sysadmin">Sysadmin</a></li>
    <ul>
       <li><a href="#shutdown">Shutting Down</a></li>
       <li><a href="#monitoring">Monitoring</a></li>
       <li><a href="#disk">Disk Management</a></li>
       <ul>
         <li><a href="#disk_linux">Linux</a></li>
         <li><a href="#disk_bsd">BSD</a></li>
         <li><a href="#disk_illumos">Solaris and Illumos</a></li>
         <li><a href="#disk_alternatives">Alternatives to FAT</a></li>
         <li><a href="#disk_network">Network File Systems</a></li>
       </ul>
       <li><a href="#power">Power Management</a></li>
       <ul>
         <li><a href="#power_freebsd">FreeBSD and DragonFly BSD</a></li>
         <li><a href="#power_openbsd">OpenBSD</a></li>
         <li><a href="#power_netbsd">NetBSD</a></li>
         <li><a href="#power_illumos">Solaris and Illumos</a></li>
       </ul>
    </ul>
    <li><a href="#security">Security</a></li>
    <ul>
    	<li><a href="#user_mng">Users and Groups</a></li>
    	<li><a href="#sudo">To Be or Not to Be Root?</a></li>
    	<li><a href="#ssh">Remote Connections</a></li>
    	<li><a href="#passwords">Remembering Passwords</a></li>
    </ul>
    <li><a href="#interactive">Making Things Interactive</a></li>
    <ul>
      <li><a href="#shortcuts">Creating Shortcuts</a></li>
      <li><a href="#menu">Creating Menus</a></li>
      <li><a href="#progress">Progressbars and Interactive Pipes</a></li>
      <li><a href="#auto">Autocompletion</a></li>
      <li><a href="#fun">Having Fun</a></li>
    </ul>
  </ul>
  <li><a href="#web">The Web</a></li>
  <ul>
    <li><a href="#connect">Connecting to the Internet</a></li>
    <ul>
      <li><a href="#wifi">Wifi without NetworkManager</a></li>
      <li><a href="#wifi_freebsd">FreeBSD and DragonFly BSD</a></li>
      <li><a href="#wifi_netbsd">NetBSD</a></li>
      <li><a href="#wifi_openbsd">OpenBSD</a></li>
      <li><a href="#wifi_illumos">Solaris and Illumos</a></li>
    </ul>
    <li><a href="#browsing">Browsing</a></li>
    <li><a href="#webapps">Web Apps</a></li>
    <ul>
      <li><a href="#weatherapp">Example 1: A Weather App</a></li>
      <li><a href="#dailyapp">Example 2: Daily Motivational's</a></li>
      <li><a href="#smsapp">Example 3: Sending SMS</a></li>
      <li><a href="#chatapp">Example 4: A Chat Client</a></li>
    </ul>
    <li><a href="#downloads">Downloads</a></li>
    <li><a href="#chatting">Chatting</a></li>
    <li><a href="#email">Email</a></li>
    <li><a href="#news">News</a></li>
    <li><a href="#socialmedia">Social Media</a></li>
    <li><a href="#hipster">Hipster Media</a></li>
  </ul>
  <li><a href="#media">Multimedia</a></li>
  <ul>
    <li><a href="#volume">Volume</a></li>
    <ul>
      <li><a href="#volume_freebsd">FreeBSD and DragonFly BSD</a></li>
      <li><a href="#volume_openbsd">OpenBSD</a></li>
      <li><a href="#volume_netbsd">NetBSD</a></li>
      <li><a href="#volume_illumos">Solaris and Illumos</a></li>
    </ul>
    <li><a href="#video">Video</a></li>
    <li><a href="#youtube">Youtube</a></li>
    <li><a href="#music">Music</a></li>
    <li><a href="#radio">Internet Radio</a></li>
    <li><a href="#spotify">Spotify, LastFM and Podcasts</a></li>
    <li><a href="#making_music">Making Music and Video</a></li>
  </ul>
  <li><a href="#graphics">Graphics</a></li>
  <ul>
    <li><a href="#pictures">Pictures</a></li>
    <li><a href="#pdf">PDF and Postscript</a></li>
    <li><a href="#ocr">OCR</a></li>
    <li><a href="#ascii">Asciiart</a></li>
  </ul>
  <li><a href="#peripherals">Peripherals</a></li>
  <ul>
    <li><a href="#usb">USB Memory Sticks</a></li>
    <li><a href="#dvd">CD's, DVD's and BlueRays</a></li>
    <li><a href="#printer">Printers and Scanners</a></li>
  </ul>
  <li><a href="#game">Gaming</a></li>
  <ul>
    <li><a href="#strategy_games">Strategy Games</a></li>
    <li><a href="#framebuffer_games">Framebuffer Games</a></li>
    <li><a href="#roguelikes">Roguelikes</a></li>
    <li><a href="#if">Interactive Fiction</a></li>
    <li><a href="#mud">MUD's</a></li>
    <li><a href="#edu">Edutainment</a></li>
    <li><a href="#misc">Misc Fun</a></li>
  </ul>
  <li><a href="#office">Office</a></li>
  <ul>
    <li><a href="#documents">Reading Documents</a></li>
    <ul>
      <li><a href="#libreoffice">LibreOffice</a></li>
      <li><a href="#epub">E-Books</a></li>
      <li><a href="#cbr">CBR Comic Books</a></li>
    </ul>
    <li><a href="#spelling">Writing Text and Spell Checking</a></li>
    <li><a href="#dictionary">Dictionaries and Translation</a></li>
    <li><a href="#writing">Writing Documents</a></li>
    <ul>
      <li><a href="#troff">Troff</a></li>
      <li><a href="#tex">Tex</a></li>
      <li><a href="#docbook">Docbook</a></li>
    </ul>
    <li><a href="#spreadsheets">Spreadsheets and Databases</a></li>
    <ul>
      <li><a href="#sqlite">Sqlite</a></li>
      <li><a href="#awk">AWK</a></li>
    </ul>
    <li><a href="#presentation">Presentations</a></li>
    <li><a href="#math">Math and Graphs</a></li>
    <li><a href="#mindmap">Mindmaps and Flowcharts</a></li>
    <li><a href="#pim">PIM</a></li>
    <ul>
      <li><a href="#2do">2do lists</a></li>
      <li><a href="#que">Queues</a></li>
      <li><a href="#calendar">Calendar</a></li>
      <li><a href="#marking_calendar">Marking The Calendar</a></li>
      <li><a href="#password_mng">Password Manager</a></li>
      <li><a href="#accounting">Accounting</a></li>
      <li><a href="#addresses">Address Book</a></li>
      <li><a href="#bookmarks">Bookmarks</a></li>
      <li><a href="#timetracker">Keeping Track of Time</a></li>
    </ul>
  </ul>
  <li><a href="#x11">Console and X11 Integration</a></li>
  <ul>
    <li><a href="#retrieving">Retrieving Console Data</a></li>
    <li><a href="#console_desktop">Putting a Console on the Desktop</a></li>
    <li><a href="#desktop_console">Putting a Desktop on the Console</a></li>
  </ul>
  <li><a href="#conclusion">Conclusion</a></li>
</ul>


<h2 id="intro">What is a Console..?</h2>

<p>
A <i>console</i> in UNIX speak
(<i>UNIX</i>..? think Linux - best to confuse one concept at a time!) 
is the text-based interface,
as opposed to the graphical interface
(the "desktop" in people speak).
The console is sometimes referred to as a "tty"
(short for 
<a href="https://en.wikipedia.org/wiki/Teleprinter">"teletype"</a>, 
which is graybeard speak - the kind of people who refer to a monitor as a 'glass teletype'...)
You can change between consoles and the graphical environment by holding the keys <kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>Function-Key</kbd>
(eg. <kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>F1</kbd> will change to tty1 - the first console).
Exactly how many consoles are available,
and where the graphical environment is located,
depends greatly on which version of UNIX you are running,
and how it is configured.
More on that later,
but feel free to experiment!
A console
(technically a <i>virtual</i> console) 
is not the same as a terminal emulator,
such as XTerm,
which is a program you can run within a graphical environment.
Neither is it a <i>shell</i> by the way,
a shell like <samp>bash</samp> for instance runs inside a terminal emulator/virtual console.
Confusion reigns supreme however since terminal emulators and virtual consoles are often just called "terminals", "consoles" or "shells" interchangeably.
(btw, all of them are "cli's" - command line interfaces)
</p>

<p>
If you feel confused at this point,
the following analogy might help:
Think of a "shell" as a language, such as English.
A "console" as an oldschool office from the 50's,
with only basic essentials like a typewriter and a filing cabinet.
And a "desktop" as a modern office of plexiglas and shiny chrome,
complete with air conditioning,
a coffee machine,
fancy artwork on the walls,
soft ambient background music and what not.
It even has some pencils and papers laying around somewhere if people get in a productive mood...
Although the office environments are certainly different,
and reflect different time periods,
in practice the occupants often work on the same things,
and of course they all use the same language.
</p>

<h2 id="serious">A Console Desktop? Seriously?</h2>

<p>
Yes.
The text-based environment in UNIX is incredibly versatile and powerful,
programmers and system administrators who log into a UNIX server remotely will typically work exclusively in the console,
working on a remote desktop
(similar to team-viewer in Windows)
is just too inefficient.
But can a console really function as an everyday "desktop"?
That is what this article will try to explore,
and I think you will be pleasantly surprised at just how useful a text-based environment can be!
</p>

<p>
Useful you say? 
Isn't a text based environment like... <i>boring</i>?!?
That depends.
Learning to use the console certainly requires effort,
just as it does to learn any language.
But once mastered, you don't think much about it as either boring or fun,
instead you focus on the task at hand.
An article you read might peak your interest or not,
but you wouldn't consider the English language itself as boring would you?
Once a language is learned you don't think much about it.
</p>

<p>
Since our goal here is to illustrate day-to-day "desktop" usage,
we will try to avoid going into system administration and programming as much as possible
(although we will have to dip our toes into such matters a little bit).
The internet is brimming with articles on these matters,
so just google around if you need some help ;)
The article assumes you are already familiar with basic UNIX commands,
and many solutions are provided as shell scripts.
If you don't have the skill to read such programs,
the following books may be useful additions to your bookshelf:
</p>

<p>
<ul>
<li><i>The UNIX Programming Environment</i> by Kernighan and Pike</li>
<li><i>The AWK Programming Language</i> by Aho, Kernighan and Weinberger</li>
<li><i>UNIX Power Tools</i> from O'Reilly</li>
<li><i>The Handbook</i> from the FreeBSD project</li>
<li><i>The Linux Bible</i> from Wiley</li>
<li><i>The Linux Command Line and Shell Scripting Bible</i> from Wiley</li>
</ul>
</p>

<p>
Despite not delving deeply into administration and programming however,
we will cover much ground and therefore I try to give brief instructions.
You are encouraged to read the manpages and relevant documentation yourself to get the finer details.
Finally we will not talk much about Emacs.
This editor deserves a desktop howto article all on it's own,
and thus we try to avoid it not to digress to far off topic.
</p>

<p>
I will start off by discussing how to configure and use the console,
and introduce some basic topics.
Although necessary,
this first section is mindnumbingly boring,
so you might want to skip ahead to the <a href="#fun">fun</a> parts.
</p>

<h2 id="basics">Basics</h2>

<p>
<a href="images/basics.png"><img src="thumbs/basics.png" title="Learning computer basics"></a>
</p>

<h3 id="consoles">Switching Consoles</h3>

<p>
As mentioned you normally have multiple virtual consoles available.
So if your waiting for a job to finish at tty1,
you can hit <kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>F2</kbd> to jump over to tty2.
When you want to go back to the first console again, 
just hit <kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>F1</kbd>.
Most systems will also allow you to scroll back the text with <kbd>Shift</kbd> + <kbd>PgUp</kbd> and <kbd>Shift</kbd> + <kbd>PgDown</kbd>,
this enables you to go back and read previous output.
In the following sections I will talk about how to configure fonts,
colors, keyboard layouts and the consoles in general.
The method of doing this varies greatly from system to system,
so you don't need to read all of the subsections,
just the ones that are relevant for you.
</p>

<h3 id="nvidia">Nvidia</h3>

<p>
This hardware vendor deserves special mention.
Now I know that many a Windows gamer out there loves his Nvidia card like his favorite pet monkey.
And sure enough the Nvidia engineers can produce stunning specs,
but they cannot write quality software if their life depended on it!
Their driver is a bad joke,
and an affront to the finer feelings of system administrators everywhere.
It is clear that the Nvidia developers have the Windows mindset,
where it is perfectly fine,
nay <i>expected</i>,
to write binary blobs that bloat the system and boldly crash it in ways no one have crashed it before!
What's life without a little whimsy,
stability is for wimps!
</p>

<p>
If you are using their driver on any version of UNIX,
then you will most likely not be able to switch back and forth between the console and your graphical environment.
In fact you often cannot run multiple graphical environments simultaneously either,
something that is unheard of in the Windows world,
but is a given on UNIX systems.
Don't be surprised either if your system suddenly freezes or crashes for no apparent reason whatsoever,
these are classical symptoms of <s>Windows</s> Nvidia.
The only way to work around these issues is to use either the reverse engineered open source Nvidia driver,
or configure X to use the generic VESA driver.
In both cases you will have very shabby resolution,
both on your desktop and on your console.
Using the console with an Nvidia card will definitely cause lower quality of life,
if you have no choice however,
I recommend that you take a closer look at the
<a href="#console_desktop">Putting a Console on the Desktop</a> section below.
</p>

<p>
As a side note:
The OpenBSD developers have embargoed Nvidia on their system.
If more operating systems would follow their example,
instead of showing their finger in frustration
(looking at you Linus Torvalds),
Nvidia might just take a hint and clean up their act.
</p>

<p>
<i>
To be fair,
other vendors like Intel,
have also shown a shocking lack of concern for the quality of their own product.
Of course Intels specialty is multi-processing and virtualization,
not graphics,
so it's in those areas that they bury their bodies.
As far as graphics are concerned,
Intel should not give you any problems on the console.
</i>
</p>

<h3 id="desktop">Getting to the Desktop again</h3>

<p>
If you have a graphical desktop already running,
getting to it from the console is simply a question of finding out where it is.
If you are unsure just hit <kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>F1</kbd>,
then <kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>F2</kbd>,
and so on all the way up to <kbd>F12</kbd> until you hit it
(it is often at <kbd>F5</kbd> or <kbd>F7</kbd> but it varies).
Note that while some systems allow you to use the shorthand <kbd>Alt</kbd> + <kbd>Fn</kbd>,
when switching consoles,
you need to use the full keybinding sequence <kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>Fn</kbd>,
when switching back and forth between the graphical environment and the consoles.
</p>

<p>
You can also start a graphical environment from a console.
If no graphical environment is running just type <samp>startx</samp>.
This will launch the systems default graphical environment,
which is often <samp>twm</samp>,
a horribly antiquated window manager.
(many who see this for the first time do not realize they are running a desktop,
they just assume that the computer got broken somehow)
You can configure startx to run something else by adding instructions in <samp>~/.xinitrc</samp>
(that is <samp>.xinitrc</samp> in your home directory).
Here is a short example that sets the keyboard layout to Italian and launches Xfce:
</p>

<p>
<pre>
<samp>
setxkbmap it
exec dbus-launch --exit-with-session startxfce4
</samp>
</pre>
</p>

<p>
<i>PS:</i>
Getting the launch instructions right for a modern desktop,
such as KDE or GNOME,
can be tricky.
If you're having problems starting them I suggest you first test X
(the traditional graphical engine in UNIX),
with a simple window manager,
such as <samp>exec openbox</samp>,
to check that the actual graphical environment is working.
If it is,
you have probably misconfigured the KDE/GNOME launch instructions.
</p>

<p>
If a graphical environment is already running you need to launch your new desktop in a different virtual screen.
You can do so like this: <samp>startx -- :2</samp>,
the number here is arbitrary,
what matters is that the screen number must be unique.
</p>

<h3 id="configuration">Configuring the Console on various Systems</h3>

<h4 id="multi-monitor">Multiple Monitors</h4>

<p>
Multi-Monitor setups is not possible on any UNIX console.
That is to say,
you can have as many monitors as you like,
but they will all show the same screen.
Multitasking however is possible,
for one,
you can configure a number of
<a href="#consoles">virtual consoles</a>
and switch between them.
(see also the
<a href="#tmux">tmux</a> section)
Secondly,
you can have a multi-monitor setup in X,
and run a
<a href="#console_desktop">"console-like"</a>
desktop,
such as dwm.
</p>

<h4 id="linux">Linux: Generic Instructions</h4>

<p>
Linux will usually configure a number of consoles by default,
6 consoles and the graphical environment on the seventh seems to be a popular configuration.
You can configure an arbitrary number of consoles on Linux,
see the next sections for further details.
You can also use the short hand <kbd>Alt</kbd> + <kbd>Fn</kbd> and <kbd>Alt</kbd> + <kbd>Arrow-Key</kbd> to change consoles.
</p>

<p>
You can set keyboard layout with <samp>loadkeys</samp>,
such as <samp>loadkeys dvorak.map</samp>.
The keyboard maps are often located in <samp>/usr/share/keymaps</samp> or <samp>/usr/share/kbd/keymaps</samp>.
(<i>PS:</i>
This approach should also work on System-D distros,
but did not work for me on Debian.
You could try <samp>dpkg-reconfigure keyboard-configuration</samp> instead
(naturally this will only work on Debian-like distros)).
You can change fonts with <samp>setfont</samp>,
such as <samp>setfont -v Uni3-Terminus12x6</samp>,
the console fonts are usually located in <samp>/usr/share/consolefonts</samp> or <samp>/usr/share/kbd/consolefonts</samp>.
</p>

<p>
The Linux console supports multiple colors and you can use <samp>echo</samp> to send control sequences to manipulate the color settings.
Adding this to the end of <samp>~/.profile</samp> will make your console use the Solarized color theme:
</p>

<p>
<pre>
<samp>
# solarize the tty
if [ "$TERM" = "linux" ]; then
	echo -en "\e]P0073642" #black
	echo -en "\e]P1dc322f" #darkgray
	echo -en "\e]P2859900" #darkred
	echo -en "\e]P3b58900" #red
	echo -en "\e]P4268bd2" #darkgreen
	echo -en "\e]P5d33682" #green
	echo -en "\e]P62aa198" #brown
	echo -en "\e]P7eee8d5" #yellow
	echo -en "\e]P8002b36" #darkblue
	echo -en "\e]P9cb4b16" #blue
	echo -en "\e]PA586e75" #darkmagenta
	echo -en "\e]PB657b83" #magenta
	echo -en "\e]PC839496" #darkcyan
	echo -en "\e]PD6c71c4" #cyan
	echo -en "\e]PE93a1a1" #lightgray
	echo -en "\e]PFfdf6e3" #white
	clear #for background artifacting
fi
</samp>
</pre>
</p>

<h4 id="framebuffer">Linux Framebuffer</h4>

<p>
Not only can the Linux console display any number of colors,
but it is also capable of displaying real graphics.
It can do so using the framebuffer device.
In order to use it you must first make sure your user has permission to access <samp>/dev/fb0</samp> and the files under <samp>/dev/input</samp>.
This usually mean you need to add your user to the groups <samp>video</samp> and <samp>input</samp>,
you can do so by running this command: <samp>usermod -a -G video,input myusername</samp>.
You also need to install the <samp>fbdev</samp> driver,
if it isn't already included.
The method of doing so varies from distro to distro.
For instance on Slackware you can do this: <samp>installpkg /mnt/cdrom/extra/xf86-video/*.txz</samp>, 
and on Debian: <samp>apt install xserver-xorg-video-fbdev fbset gpm</samp>.
Look up your distros documentation.
</p>

<p>
Two examples of a programs you can use on the Linux framebuffer is <samp>fbterm</samp> and <samp>fbi</samp>.
The <samp>fbterm</samp> terminal can use any fonts available under the graphical environment,
which easily enables you to have support for exotic languages like Arabic or Chinese.
In combination with the image viewer <samp>fbi</samp>,
you can also set a wallpaper for this terminal.
(<i>Ps</i>:
You cannot launch another framebuffer program from within fbterm,
you need to do that from a regular console)
</p>

<p>
<a href="images/fbterm.png"><img src="thumbs/fbterm.png" title="Fancy themeing and exotic characters are possible with fbterm"></a>
</p>

<p>
<pre>
<samp>
#!/bin/sh
# fbtermbg - start fbterm with wallpaper
# usage:  fbtermbg wallpaper
# depend: fbi

(sleep 1; cat /dev/fb0 > /tmp/wallpaper.fbimg) &
fbi -t 2 -1 --noverbose -a $1
export FBTERM_BACKGROUND_IMAGE=1
cat /tmp/wallpaper.fbimg > /dev/fb0
fbterm
</samp>
</pre>
</p>

<p>
Some framebuffer programs will hijack your screen,
so that you cannot switch to other consoles or the graphical environment.
Don't panic!
Everything should return to normal once you have quit the program.
(<i>Ps</i>:
If your console is all garbled after you have quit a framebuffer program,
the <samp>reset</samp> command should fix it)
</p>

<h4 id="systemv">Non-System-D Linux</h4>

<p>
Legacy Linux systems,
and a few modern exceptions,
such as Slackware, Gentoo and CRUX,
do not use System-D.
</p>

<p>
You can change virtual console settings in <samp>/etc/inittab</samp>.
To add an eighth tty in Slackware,
add this line to <samp>/etc/inittab</samp>:
</p>
<p>
<pre>
<samp>
c8:12345:respawn:/sbin/agetty 38400 tty8 linux
</samp>
</pre>
</p>
<p>
This takes effect after a reboot.
In non-System-D Linux you can also switch to tty13-24 with <kbd>AltGr</kbd> + <kbd>Fn</kbd>.
</p>

<p>
Slackware boots in a text based environment by default,
to change this to a graphical login,
change the line:
<samp>id:3:initdefault</samp> to <samp>id:4:initdefault</samp> in <samp>/etc/inittab</samp>.
On non-System-D Linux runlevel <b>3</b> is text mode login,
where as runlevel <b>4</b> is graphical login.
The process described here should be fairly similar to any Linux distribution that doesn't use System-D.
</p>

<h4 id="systemd">System-D Linux</h4>

<p>
Most modern Linux systems,
including Debian, Redhat, SUSE, Arch,
and quite a few others,
use System-D.
</p>

<p>
To change the number of consoles, to say 12, in Debian,
uncomment <samp>NAutoVTs</samp> in <samp>/etc/systemd/logind.conf</samp> and set it to <samp>NAutoVTs=12</samp>.
This will take effect after a reboot.
On Linux systems with System-D, 
you can switch between the tty13-24 with <kbd>Shift</kbd> + <kbd>Alt</kbd> + <kbd>Fn</kbd>.
</p>

<p>
Configuring Debian to boot into text mode instead of a graphical login,
do this: <samp>systemctl set-default multi-user.target</samp>,
to switch back to graphical login do this:
<samp>systemctl set-default graphical.target</samp>.
The process described in this section should be fairly similar to any Linux distribution that uses System-D.
</p>

<h4 id="nonlinux">Non-Linux Systems: A Reminder</h4>

<p>
Linux users often take a lot for granted,
they tend to get horrified when discovering that a different UNIX system doesn't have some functionality they have gotten used to,
or even if they just do things differently.
(they may even shout <i>"this isn't UNIX!!!"</i> without realizing the irony - it's usually Linux that's doing things in a non-Unixy fashion)
So if you're planning to use a BSD system or some other UNIX variety,
and have a Linux background,
have an open mind and be prepared to adjust your expectations!
</p>

<p>
When it comes to the console,
non-Linux systems will not support graphics on the framebuffer,
nor support exotic UTF-8 characters (ei. English only),
and color and font support is often very limited.
In fact many ncurses applications may not work well on non-Linux consoles.
Some systems also restrict how many consoles you are allowed to have.
If you think this all sounds horribly limiting,
remember that real UNIX graybeards consider "graphics",
"colors" and non-ASCII text to be script-kiddie fads.
(having that said,
all of these restrictions can be easily overcome by simply running
<a href="#console_desktop">terminal emulators in a graphical desktop</a>).
Lastly keybindings might be a little different,
although <kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>Fn</kbd> will always work.
</p>

<p>
Despite these restrictions however,
you can still do neat things on any UNIX console with a little knowhow.
The above mentioned trick to make a Solarized console theme in Linux will not work on most UNIX consoles since they don't support 256 colors,
but virtually all of them have 8 color ANSI support,
so you can do some basic color tweaking.
Here is a simple and portable script that can set a few basic tty color schemes
(unlike the Linux trick though,
the themes are not preserved if you run a terminal application with colors,
such as vim or less,
so a better solution is to configure your system to use the colors you want
- more on that later):
</p>

<p>
<pre>
<samp>
#!/bin/sh
# ttycolor - choose tty colors
# usage: ttycolor theme
# bugs:  not persistent across colorful tty apps
#
# explanation:
# printf '\e[1m'  - turn on boldface (or "light" color)
# printf '\e[0m'  - turn off boldface (or "dark" color)
# printf '\e[4nm' - specify background color ("boldface" has no effect)
# printf '\e[3nm' - specify foreground color, where n is:
# 0 = black 2 = green   4 = blue    6 = cyan
# 1 = red   3 = yellow  5 = magenta 7 = white

usage(){
	echo 'Usage: ttycolor (geek|tron|minoca|sun|obsd|nuke|default)' >&2
	exit 1
}
if [ ! $# = 1 ]; then
	usage
fi

# set tty colors
case $1 in
	geek) printf '\e[0m\e[32m\e[40m' ;;	# green on black
	tron) printf '\e[1m\e[36m\e[40m' ;;	# cyan on black 
	minoca) printf '\e[1m\e[33m\e[42m' ;;	# yellow on green
	sun)  printf '\e[0m\e[30m\e[47m' ;;	# black on white
	obsd) printf '\e[1m\e[37m\e[44m' ;;	# white on blue
	nuke) printf '\e[1m\e[33m\e[41m' ;;	# yellow on red
	default) printf '\e[0m\e[37m\e[40m' ;;	# white on black
	*) usage ;;
esac
clear
</pre>
</samp>
</p>

<h4 id="freebsd">FreeBSD and DragonFly BSD</h4>

<p>
<i>FreeBSD</i> has 8 virtual consoles configured and the graphical interface on the ninth by default.
Modern versions of FreeBSD use the <samp>vt(4)</samp> console driver.
It allows you to configure up to 16 consoles,
and switch to tty13-16 with <kbd>Shift</kbd> + <kbd>Alt</kbd> + <kbd>F1</kbd> ... <kbd>F4</kbd>.
You can also use the <kbd>Alt</kbd> + <kbd>Fn</kbd> shortcut,
but not the arrow keys.
To scroll backwards and read previous output hit <kbd>Scroll Lock</kbd>,
and then use <kbd>Page Up</kbd> and <kbd>Page Down</kbd>,
hit <kbd>Scroll Lock</kbd> again when you are done.
To configure more than 8 consoles edit <samp>/etc/ttys</samp>,
for instance this line:
<samp>ttyv9 "/usr/libexec/getty Pc" xterm on secure</samp>
will enable a ninth console.
To enable all 16 consoles use <samp>ttyva</samp> ... <samp>ttyvf</samp>,
don't use <samp>ttyv10</samp> ... <samp>ttyv15</samp>!
You can tweak the other console settings by adding options to <samp>/etc/rc.conf</samp>.
For instance adding these lines:
</p>

<p>
<pre>
<samp>
moused_enable="YES"
allscreens_flags="-f 8x8 /usr/share/vt/fonts/terminus-b32.fnt green"
keymap="us.dvorak.kbd"
kld_list="i915kms"
</samp>
</pre>
</p>

<p>
will enable the console mouse,
use large green terminus fonts and the dvorak keyboard layout.
Lastly it will load the intel graphics firmware,
you need to have the <samp>drm-kmod</samp> package installed for this to work
(if you are using nvidia or radeon you need to change this line accordingly).
You can interactively select a console font with <samp>vidfont</samp>,
or use the <samp>vidcontrol</samp> command to adjust all of the above settings.
</p>

<p>
Even with 16 ttys configured in <samp>/etc/ttys</samp>,
FreeBSD limits you to a maximum of 12 consoles by default,
to add up to 16,
you need to tweak the kernel a bit:
</p>

<p>
<pre>
<samp>
# <i>cd /usr/src/sys/$(uname -m)/conf</i>
# <i>cp GENERIC MYKERN</i>
# <i>sed -i '' 's/GENERIC/MYKERN/' MYKERN</i>
# <i>echo options VT_MAXWINDOWS=16 >> MYKERN</i>
# <i>cd /usr/src</i>
# <i>make buildkernel KERNCONF=MYKERN</i>
# <i>make installkernel KERNCONF=MYKERN</i>
# <i>shutdown -r now</i>
</samp>
</pre>
</p>

<p>
<i>DragonFly BSD</i>
uses the old <samp>sc(4)</samp> console driver from FreeBSD,
but otherwise the setup is exactly the same.
By the way,
you don't need to tweak the kernel in order to enable all 16 consoles,
like you do in FreeBSD.
(<i>PS:</i>
the sc driver might have problems switching between the graphical environment and consoles)
</p>

<p>
<i>
PS: BSD systems write kernel messages to the first console.
This can be quite annoying if you happen to be working on other things there,
so work on a different console then the first one to avoid much consternation.
</i>
</p>

<h4 id="openbsd">OpenBSD</h4>
<p>
OpenBSD uses the <samp>wscons(4)</samp> console driver.
It requires you to switch between consoles using
<kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>Fn</kbd>,
you cannot use the shorthand
<kbd>Alt</kbd> + <kbd>Fn</kbd>.
This is a design choice, 
made to avoid keybinding conflicts.
Also there is no way to physically switch beyond 12 consoles.
</p>

<p>
In <i>OpenBSD</i> you have five consoles enabled by default,
the fifth tty is reserved for the graphical environment.
Adding more consoles in done in <samp>/etc/ttys</samp>:
</p>
<pre>
<samp>
ttyC7 "/usr/libexec/getty std.9600" pccon0 on secure
</samp>
</pre>
</p>
Oh, and by the way once your editing </samp>/etc/ttys</samp>,
change the <samp>vt220</samp> option for your active consoles to <samp>pccon0</samp>.
vt220 is a <s>ultra-conservative</s> safe choice,
but pccon0 has more modern capabilities,
such as unicode, colors and curses.
(<i>PS</i>:
console 11 and 12 must be <samp>ttyCa</samp> and <samp>ttyCb</samp>)
</p>

<p>
Rebooting will not activate your new consoles however,
you need to "create" them first.
Doing so manually is a bit tedious,
instead we can recompile the kernel with some new settings:
</p>

<p>
<pre>
<samp>
# <i>cd /usr/src/sys/arch/$(uname -m)/conf</i>
# <i>cp GENERIC.MP CUSTOM</i>
</samp>
</pre>
</p>

<p>
(Assuming you are running a multi-processor kernel,
if not copy GENERIC)
Now open up <samp>CUSTOM</samp> in an editor and add the following lines:
</p>

<p>
<pre>
<samp>
option WS_KERNEL_FG=WSCOL_WHITE
option WS_KERNEL_BG=WSCOL_BLACK
option WS_DEFAULT_FG=WSCOL_GREEN
option WS_DEFAULT_BG=WSCOL_BLACK
option FONT_BOLD8x16
</samp>
</pre>
</p>

<p>
These settings will result in kernel messages being written in a white font,
and normal text in green.
We also changed the font to a smaller type,
fitting more text onto our screen
(you'll find a list of available fonts in <samp>/usr/src/sys/dev/wsfont/wsfont.c</samp> if you have installed sources).
Finally change the <samp>WSDISPLAY_DEFAULTSCREEN=6</samp> to <samp>WSDISPLAY_DEFAULTSCREEN=12</samp> in <samp>GENERIC</samp>.
(regardless of whether you are running a multi-processing kernel or not)
Now that the customization's are done,
we can recompile:
</p>

<p>
<pre>
<samp>
# <i>config CUSTOM</i>
# <i>cd ../compile/CUSTOM</i>
# <i>make clean</i>
# <i>make</i>
# <i>make install</i>
# <i>shutdown -r now</i>
</samp>
</pre>
</p>

<p>
<i>PS:</i>
X is big, bloated and old,
it is a mayor security risk!
The OpenBSD developers are somewhat conscientious about security...
They have therefore reconfigured X to run in user mode,
denying it any direct access to the system.
This is great for security,
but a consequence of doing so is that you cannot run more than one graphical environment at a time.
You can use <samp>Xephyr</samp> or <samp>Xnest</samp> to nest X instances inside each other though
(eg. <samp>(Xephyr :2 -screen 1920x1080 &); sleep 1; DISPLAY=:2 openbox</samp>).
Also the normal way of starting X in OpenBSD from the console is not with <samp>startx</samp>,
but rather <samp>doas xenodm</samp>,
which starts the xdm-like login manager.
Finally,
as mentioned OpenBSD does not support Nvidia cards.
Graphics may still "work" on such cards,
but you will only get generic VESA output
(very poor resolution).
</p>

<p>
<i>
PS: OpenBSD, like all BSD systems, write kernel messages to the first console.
So it's a good idea to work on a different console to avoid interruptions.
</i>
</p>

<h4 id="netbsd">NetBSD</h4>

<p>
NetBSD also uses the <samp>wscons(4)</samp> console driver,
like OpenBSD.
It requires you to switch between consoles using
<kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>Fn</kbd>,
you cannot use the shorthand
<kbd>Alt</kbd> + <kbd>Fn</kbd>.
There is no way to physically switch beyond 12 consoles.
</p>

<p>
Configuring the <i>NetBSD</i> console is fairly similar to OpenBSD.
Add new consoles to <samp>/etc/ttys</samp>, for instance:
<br>
<samp>ttyE7 "/usr/libexec/getty Pc" wsvt25 on secure</samp>
<br>
NetBSD has 4 consoles by default and uses the fifth as the graphical interface,
We can change some of the kernel defaults and recompile like so:
</p>

<p>
<pre>
<samp>
# <i>cd /usr/src/sys/arch/$(uname -m)/conf</i>
# <i>cp GENERIC CUSTOM</i>
# <i>vi CUSTOM</i>
</samp>
</pre>
</p>

<p>
Now change <samp>WS_KERNEL_FG=WSCOL_GREEN</samp> to <samp>WS_KERNEL_FG=WHITE</samp>,
and add <samp>WS_DEFAULT_FG=WSCOL_GREEN</samp>.
Uncomment <samp>WSDISPLAY_DEFAULTSCREENS=4</samp> and change it to <samp>WSDISPLAY_DEFAULTSCREENS=8</samp>,
and add <samp>FONT_DEJAVU_SANS_MONO12x22</samp>
(you'll find a list of available fonts in <samp>/usr/src/sys/dev/wsfont/wsfont.c</samp> if you have installed sources).
Then compile the kernel with these changes:
</p>

<p>
<pre>
<samp>
# <i>config CUSTOM</i>
# <i>cd ../compile/CUSTOM</i>
# <i>make depend</i>
# <i>make</i>
# <i>mv /netbsd /netbsd.old</i>
# <i>mv netbsd /</i>
# <i>shutdown -r now</i>
</samp>
</pre>
</p>

<p>
By default the NetBSD kernel only allows you to have a maximum of 8 consoles.
Enabling more than that would require some serious kernel hacking,
I recommend using <a href="#tmux"><samp>tmux</samp></a> instead...
</p>

<p>
<i>
PS: NetBSD, like all BSD systems, write kernel messages to the first console.
So it's a good idea to work on a different console to avoid interruptions.
</i>
</p>

<h4 id="illumos">Solaris and Illumos</h4>

<p>
Oddly enough virtual consoles have traditionally not been available on Solaris,
and it does not come enabled by default in newer versions,
such as OpenIndiana,
either.
To add six consoles in OpenIndiana for instance,
you need to run:
</p>

<p>
<pre>
<samp>
# <i>svcadm enable vtdaemon</i>
# <i>for i in 2 3 4 5 6; do</i>
> 	<i>svcadm enable console-login:vt$i</i>
> <i>done</i>
# <i>svccfg -s vtdaemon setprop options/secure=false</i>
# <i>svccfg -s vtdaemon setprop options/hotkeys=true</i>
# <i>svcadm refresh vtdaemon</i>
# <i>svcadm restart vtdaemon</i>
</samp>
</pre>
</p>

<p>
By default you are only allowed to activate a maximum of 6 consoles.
Like Linux you can change between consoles using the <kbd>Alt</kbd> + <kbd>Fn</kbd> for ttys 1-12,
and <kbd>AltGr</kbd> + <kbd>Fn</kbd> for ttys 13-24,
or you can use the <kbd>Alt</kbd> + <kbd>Arrow-Key</kbd> shortcuts.
To get back to the desktop hit <kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>F7</kbd>.
Not all graphical drivers will allow you to switch between console and desktop however.
On one of my test machines I had to disable the graphical environment with <samp>svcadm disable lightdm</samp> and do a cold reboot.
From the console I could then enable the desktop again with <samp>svcadm enable lightdm</samp>,
but to get to the console again I would have to do another disable and reboot.
</p>

<p>
I was able to work around these problems by configuring X to use the generic vesa driver,
but naturally this meant that I had a very poor screen resolution.
Hopefully your graphic driver will be more cooperative.
If not it might be better to ignore the tty consoles altogether and use
<a href="#console_desktop">terminal emulators in a graphical desktop</a> instead
(not all of the applications mentioned in this reference are available in the Solaris repositories).
But if you really want to use the vesa graphics driver you can do so by adding this file in <samp>/etc/X11/xorg.conf.d/vesa.conf</samp>:
</p>

<p>
<pre>
<samp>
Section "Device"
	Identifier "Card0"
	Driver "vesa"
EndSection
</samp>
</pre>
</p>

<p>
The only way I have managed to add more then 6 consoles in Solaris is the following hackish method:
edit <samp>/lib/svc/manifest/system/console-login.xml</samp> as root,
find the <samp>&lt;instance name='vt6' enabled='false'&gt;</samp> line and copy this until the trailing <samp>&lt;/instance&gt;</samp>.
Edit the copy so that it reads <samp>vt8</samp> and <samp>/dev/vt/8</samp>,
instead of <samp>vt6</samp> and <samp>/dev/vt/6</samp>,
in the three places that these values are mentioned.
You can now repeat this process for vt's 9-15.
Reboot and run the above svcadm commands for vt's 9-15 and you now have 14 consoles (vt7 is still reserved for the desktop).
If you want more then 14 consoles you need to make more device files in <samp>/dev/vt</samp> first,
don't ask me how...
</p>

<p>
Setting the console keyboard layout,
to say French, 
is done with <samp>kbd -s French</samp>.
To choose a language interactively just type <samp>kbd -s</samp>.
In theory,
running this command as root should change your default console keyboard layout permanently,
but due to a bug in the version of OpenIndiana I tested this on,
it got reset to US qwerty on every reboot.
I have yet to figure out how to adjust fonts and default colors in the Solaris console,
or use the mouse and scrollback buffer
(I suspect this doesn't work on all hardware).
</p>

<h3 id="organize">Getting Organized</h3>

<p>
<a href="images/organized.png"><img src="thumbs/organized.png" title="The art of getting organized"></a>
</p>

<p>
The process,
nay the <i>art</i>,
of getting organized is a complex and abstract topic.
We will not even try to present a self-help-book-like theory of how to do this!
(there are plenty of those on Amazon if you are into that sort of thing...)
What we will do is show you the tools you need,
and leave it as an exercise for the reader to figure out what to do with them...
(sidenote: one of the "benefits" of using the console is that you actually <i>have to</i> get organized)
</p>

<p>
You are probably familiar with the basic tools such as 
<samp>ls</samp>, <samp>cd</samp>, <samp>mkdir</samp>, <samp>rm</samp>, <samp>ln</samp>, <samp>pwd</samp> and so on.
The problem of organizing yourself on the command line though,
is that your files are largely out of view.
<i>"Out of sight, out of mind"</i> as they say.
You can quickly check what the filesystem looks like with the <samp>tree</samp> command.
(if there is to much output try <samp>tree -L 1</samp> or <samp>-L 2</samp>).
Another fantastic tool to quickly get an overview of your files,
including their contents,
is the file manager <samp>ranger</samp>
(alternatively <samp>mc</samp>).
On the other hand,
if you just need to figure out what's taking so much space of your harddrive try <samp>ncdu</samp>.
</p>

<p>
<a href="https://pspodcasting.net/images/dan/blog/2018/tree.png"><img src="thumbs/tree.png" title="Use tree, ranger and ncdu to get a quick overview of your files"></a>
</p>

<p>
Sometimes though you don't need to get a general overview,
but find a specific file that you have lost.
The quickest way to do this is <samp>locate myfile</samp>.
But the <samp>locate</samp> command has a weakness,
it relies on a database that needs to be updated manually
(read the man page for the specifics).
If the database is out of date, it may not contain the file your looking for.
(tip: update the locate database periodically with a cron job)
Worse, you may not remember the exact name,
you only remember certain details,
such as general filesize and when you last worked on it.
<samp>find</samp> is your friend!
This command can do some impressive file searching,
here are some examples:
</p>

<p>
Search for a directory named exactly "MyDiR" somewhere under /some/path:
<pre>
<samp>
$ <i>find /some/path -type d -name MyDiR</i>
</samp>
</pre>
</p>

<p>
Search for a pdf file somewhere under the current directory that is more then 10 megabytes in size but less then 100:
<pre>
<samp>
$ <i>find . -iname *.pdf -size +10M -size -100M</i>
</samp>
</pre>
</p>

<p>
Case insensitive search for a file called "mydir" somewhere under the current directory,
modified within the last 10 days and belonging to the "www" group:
<pre>
<samp>
$ <i>find . -type f -iname mydir -group www -mtime -10</i>
</samp>
</pre>
</p>

<p>
Last but not least,
don't forget the invaluable <samp>grep</samp> command.
With it you can recursively search for any file containing a certain text,
eg:
<pre>
<samp>
$ <i>grep -R "UNIX is awesome" /some/path</i>
</samp>
</pre>
</p>

<h3 id="jobs">Multitasking: Jobs</h3>

<p>
A terminal can also run multiple programs at once.
You have probably launched programs in the background before with <samp>command &</samp>.
What you may not realize is that you can easily switch programs from the background to the foreground arbitrarily.
To demonstrate:
Type <samp>sleep 60 &</samp> and hit enter, three times,
now run <samp>jobs</samp>,
and you will see these three background processes listed.
Put job number 2 to the foreground with <samp>fg 2</samp>.
Your console is now unresponsive,
it is busy sleeping.
Hit <kbd>Ctrl</kbd> + <kbd>z</kbd> and you will suspend the process to the background again.
Run <samp>jobs</samp> again and notice that job nr 2 doesn't have a <b>&</b> sign,
it is currently paused.
You can continue the process in the background with <samp>bg 2</samp>.
</p>

<p>
Of course managing multiple jobs in this way is tedious.
Some times however you might find that you need to halt the program you are running,
and do something real quick.
Well that's easy,
hit <kbd>Ctrl</kbd> + <kbd>z</kbd>,
do your thing,
and run <samp>fg</samp> when your done.
Presto!
Your program resumes like nothing happened.
</p>

<h3 id="tmux">Multitasking: Tmux</h3>

<p>
For serious multitasking on the console you need terminal multiplexers.
Think of a multiplexer as a window manager for the terminal.
There are many alternatives,
but we will focus on <samp>tmux</samp>
(The classic multiplexer <samp>screen</samp> has similar capabilities,
while <samp>dvtm</samp> focuses more on window tiling).
</p>

<p>
To quickly demonstrate some of it's abilities do the following:
Fire up <samp>tmux</samp> and hit <kbd>Ctrl</kbd> + <kbd>b</kbd> and then <kbd>c</kbd>.
At the bottom line you will now see <samp>0:bash- 1:bash*</samp>.
This means that there are two bash programs running,
you are now seeing the program with an asterix, <samp>1:bash*</samp>.
You can change back to <samp>0:bash</samp> by hitting <kbd>Ctrl</kbd> + <kbd>b</kbd> and then <kbd>0</kbd>,
and then back to <samp>1:bash</samp> again with <kbd>Ctrl</kbd> + <kbd>b</kbd> and then <kbd>1</kbd>.
But tmux can do more...
Hit <kbd>Ctrl</kbd> + <kbd>b</kbd> and then <kbd>%</kbd>,
and you will see the screen split vertically.
Hit <kbd>Ctrl</kbd> + <kbd>b</kbd> and then <kbd>"</kbd>,
and it will split horizontally.
You can navigate between these window frames by hitting <kbd>Ctrl</kbd> + <kbd>b</kbd> and then one of the <kbd>Arrow</kbd> keys.
To resize the frames,
do the same,
but keep holding down <kbd>Ctrl</kbd> as you use the <kbd>Arrow</kbd> keys.
</p>

<p>
<a href="images/tmux.png"><img src="thumbs/tmux.png" title="Multitasking is a breeze with tmux"></a>
</p>

<p>
If you hit <kbd>Ctrl</kbd> + <kbd>b</kbd> and then <kbd>d</kbd>,
tmux will quit.
But you haven't just exited the program,
tmux is <i>detached</i>.
If you run <samp>ps -ely | grep tmux</samp>,
you will see that it is still running.
You can connect to this <samp>tmux</samp> session again by running the command <samp>tmux attach</samp>.
This functionality is invaluable when working remotely on a server.
If the internet connection is broken when you had tmux running,
just log in again and run <samp>tmux attach</samp>,
and you can continue where you left off.
Naturally you can have many tmux sessions running in the background,
use <samp>tmux ls</samp> to list them.
</p>

<p>
There is an absurd amount of things you can do with this program.
Check the <samp>tmux</samp> manpage for the gory details.
You can also check the available key-bindings with <kbd>Ctrl</kbd> + <kbd>b</kbd> and then <kbd>?</kbd>.
(the notation here can be a bit confusing:
<samp>bind-key</samp> is usually set to <kbd>Ctrl</kbd> + <kbd>b</kbd>,
so <samp>bind-key -T prefix d detach-client</samp> just means 
"hit <kbd>Ctrl</kbd> + <kbd>b</kbd> and then <kbd>d</kbd> to detach-client")
</p>

<h3 id="mouse">Copy Pasting: The Console Mouse</h3>

<p>
The console mouse daemon in Linux is <samp>gpm</samp>.
Many distros will have this enabled by default,
or at least will enable it if you install gpm.
In Slackware you can start the console mouse by:
<samp>chmod +x /etc/rc.d/rc.gpm</samp> and then reboot.
On System-D distros you can enable it with <samp>systemctl gpm.service start</samp>.
When <samp>gpm</samp> is running you should be able to see a square jump across the screen when you move your mouse,
this is the mouse "pointer".
</p>

<p>
Copy pasting with <samp>gpm</samp> is actually straight forward.
left click and drag to mark text,
any marked text is automatically copied to the <samp>gpm</samp> clipboard.
You can paste it by middle clicking
(if you don't have a middle mouse button click both buttons simultaneously).
Why the middle mouse button?!?
Actually this is the standard UNIX method,
go ahead and try it on your desktop!
The inefficient left click + copy + left click + paste method stems from Windows.
</p>

<p>
Pasting text straight to the command prompt is not that practical however,
and opening up a text editor will clear the clipboard!
So how do we copy something and save it to a file?
Simple:
Run <samp>cat << eof > myfile</samp> and hit <kbd>enter</kbd>.
Now copy paste what you want,
when your finished write <samp>eof</samp> and hit enter.
The text is now saved in <samp>myfile</samp>.
If you find this solution confusing,
I recommend reading up a bit on shell redirection.
</p>

<p>
<i>Ps</i>:
BSD systems use <samp>moused</samp> as their console mouse driver,
but it works in just the same way as <samp>gpm</samp>
(Solaris systems don't have a console mouse AFAIK).
</p>

<h3 id="copy_paste_tmux">Copy Pasting: Tmux</h3>

<p>
<samp>tmux</samp> also works great for copy pasting text,
especially since you can run windows side by side and copy paste between them.
But learning the keybindings will take a bit of practice.
First hit <kbd>Ctrl</kbd> + <kbd>b</kbd> and then <kbd>[</kbd> (ei. open bracket) to enter <i>copy mode</i>,
in this mode you can move the cursor around freely.
Navigate to the start of the text you want to copy and hit <kbd>Ctrl</kbd> + <kbd>Space</kbd>,
then navigate to the end of the text 
(the section you want should now be highlighted)
and hit <kbd>Alt</kbd> + <kbd>w</kbd>.
The text is now copied to the tmux clipboard.
You can paste it any time with <kbd>Ctrl</kbd> + <kbd>b</kbd> and then <kbd>]</kbd> (ei. close bracket).
You can manipulate the clipboard in many useful ways,
read the documentation for further details.
</p>

<p>
If the above keybindings seemed weird,
your probably not to familiar with <samp>emacs</samp>.
By default tmux uses the <samp>emacs</samp> style keybindings in copy mode.
You can use <samp>vi</samp> style instead if you want,
just add <samp>set-option -g mode-keys vi</samp> to ~/.tmux.conf.
You can now copy-paste by hitting <kbd>Ctrl</kbd> + <kbd>b</kbd> and then <kbd>[</kbd> to enter copy mode.
Start marked text with <kbd>Space</kbd>,
end it with <kbd>Enter</kbd>.
Finally paste it with <kbd>Ctrl</kbd> + <kbd>b</kbd> and then <kbd>]</kbd>.
</p>

<h3 id="sysadmin">Sysadmin</h3>

<p>
<a href="images/sysadmin.png"><img src="thumbs/sysadmin.png" title="Secret organizations, system administration, black ops, that sort of thing..."></a>
</p>

<p>
Now,
I know I promised that I wouldn't talk much about system administration.
But if you are going to use the console as a desktop,
you still need to know how do do some basic things,
like shutting down the system and so on.
In the following paragraphs we will therefore consider some basic sysadmin topics.
There sections are quite verbose since we are dealing with multiple operating systems,
but again,
you only need to read whatever is relevant for your setup.
</p>

<h3 id="shutdown">Shutting Down</h3>

<p>
There are various ways to shut down a computer,
many systems have
<samp>halt</samp>
and
<samp>reboot</samp>
for instance.
These commands are often just aliases for the
<samp>shutdown</samp>
command,
which is extremely ubiquitous
(even Windows has it for crying out loud!).
But it seems like every incarnation of this command behaves differently.
</p>

<p>
<ul>
<lh>Shutting down (now!) on various systems:</lh>
<li>Linux: <samp>shutdown -h now</samp></li>
<li>FreeBSD and DragonFly: <samp>shutdown -p now</samp></li>
<li>OpenBSD and NetBSD: <samp>shutdown -hp now</samp></li>
<li>Solaris/Illumos: <samp>shutdown -y -g 0 -i 5</samp></li>
<li>Windows/DOS: <samp>shutdown /s /t 0</samp></li>
</ul>
</p>
<p>
<ul>
<lh>Restarting (now!) on various system:</lh>
<li>Linux and BSD's: <samp>shutdown -r now</samp></li>
<li>Solaris/Illumos: <samp>shutdown -y -g 0 -i 6</samp></li>
<li>Windows/DOS: <samp>shutdown /r /t 0</samp></li>
</ul>
</p>

<h3 id="monitoring">Monitoring</h3>

<p>
<a href="images/glances.png"><img src="thumbs/glances.png" title="Glances gives you a quick overview of system resources"></a>
</p>

<p>
	One of the popular command line thrills,
	is to watch colorful streaming text,
	of presumably important information.
	The granddaddy monitoring application,
	is of course <samp>top</samp>.
	Which is the closest thing you will come to a taskmanager for the terminal
	(there is also the slightly more hip variant,
	<samp>htop</samp>).
	The BSD's ship with a very nice system monitoring app in addition,
	called <samp>systat</samp>.
	A nice alternative to <samp>systat</samp>,
	especially for non-BSD systems,
	is <samp>glances</samp>.
	And there are many,
	many other monitoring apps available.
	Just search your repository for programnames like "top" and "mon".
	Personally I don't find these programs all that useful,
	but they are handy when you want to make a cool screenshot of your terminal ;)
</p>

<h3 id="disk">Disk Management</h3>

<p>
To check overall disk usage run the <samp>df -h</samp> command.
You can also check how much space a directory uses with <samp>du -hs mydir</samp>,
or recursively check how much space each file in this directory uses with <samp>du -ha mydir</samp>.
</p>

<p>
You can quickly check what disks are mounted on your system with <samp>mount | column -t</samp>,
or by checking the systems disk configuration file <samp>/etc/fstab</samp>.
Note that disks are handled very differently on UNIX then on Windows.
In Windows each disk is its own top level directory beginning with its drive letter,
such as <samp>C:\</samp>.
In UNIX a disk is represented as a file in <samp>/dev</samp> and is usually called something like <samp>sda</samp>,
and in contrast to Windows it can be mounted anywhere on the filesystem.
For example a common configuration is to put the root filesystem,
<samp>/</samp>,
on a fast but small SSD harddisk,
and have the home partition,
<samp>/home</samp>,
on a slower but bigger harddisk.
Or to have partitions that change files rapidly,
like <samp>/tmp</samp> or <samp>/var</samp>,
or faster harddisks.
The point is that you can arrange the disks anywhere you want in the filetree,
and with new filesystems like ZFS,
UNIX systems allow for even greater flexibility!
</p>

<p>
We cannot go into the finer details of every UNIX filesystem,
but as an example,
lets repartition and reformat a USB memory stick with the ultra archaic and portable DOS filesystem, 
and mount it:
</p>

<h4 id="disk_linux">Linux</h4>

<p>
After attaching the USB stick to your computer,
you can run the <samp>dmesg | tail</samp> command to see if your system has detected it.
You should be able to see something similar to this line towards the end:
</p>

<p>
<samp>[ 4198.053323] sd 8:0:0:0: [sdd] Attached SCSI removable disk</samp>
</p>

<p>
Don't worry to much about the details here,
what's important is that the kernel detected a <samp>removable disk</samp> and called it <samp>sdd</samp>.
Armed with this information we can now reformat our disk:
</p>

<p>
<pre>
<samp>
# <i>fdisk /dev/sdd</i>
> <i>p</i> # Print a list of partitions that are on the disk
> <i>d</i> # Delete the partition(s)
> <i>n</i> # Create a new partition (just go with the defaults)
> <i>t</i> # Change the partition type to <i>b</i> - W95 FAT32
> <i>p</i> # List partitions and verify that everything looks correct
> <i>w</i> # Write changes to disk
</samp>
</pre>
</p>

<p>
There are more user friendly alternatives to fdisk such as <samp>cfdisk</samp>,
but the classic <samp>fdisk</samp> command is easy enough once you have used it a couple of times.
Even though we have now created a new partition table on our memory stick,
we haven't actually created a filesystem on it.
Assuming the memory stick has only one partition,
we can create a fat filesystem on it like so:
<samp>mkfs.vfat /dev/sdd1</samp>
</p>

<p>
Now that our memory stick has a freshly reformatted filesystem,
how do we use it?
Well we need to mount it somewhere on the filesystem.
For instance if you run the command <samp>mount /dev/sdd1 /home/myuser/Documents</samp>,
you can access the memory stick from this directory.
Of course that's a rather daft place to put it since you then cannot access your documents.
So lets place it somewhere else
(don't worry,
your documents will pop back once we unmount the memory stick):
</p>

<p>
<pre>
<samp>
# <i>umount /home/myuser/Documents</i>
# <i>mkdir -p /mnt/usb</i>
# <i>mount /dev/sdd1 /mnt/usb</i>
</samp>
</pre>
</p>

<p>
And safely remove it by:
<pre>
<samp>
# <i>umount /mnt/usb && eject /dev/sdd1</i>
</samp>
</pre>
</p>

<h4 id="disk_bsd">BSD</h4>

<p>
You can check what the usb stick is called with the <samp>dmesg | tail</samp> command,
or just by logging into tty1 and see what the kernel has written there.
On FreeBSD/DragonFly the device will be called something like <samp>da0</samp> and the first partition is <samp>da0s1</samp>.
On OpenBSD and NetBSD the device will be called something like <samp>sd0</samp>,
and you can then check what the partitions are called with <samp>disklabel sd0</samp>.
</p>

<p>
The <samp>fdisk</samp> command is slightly different on all the BSD versions,
so read the man page before using it.
On FreeBSD/DragonFly and NetBSD you can run <samp>fdisk -u diskname</samp>,
and an interactive process will guide you through the partitioning.
(make sure you choose file type <samp>11</samp> on your FAT partition).
In OpenBSD run <samp>fdisk -e diskname</samp> to edit the partition,
use file type <samp>0b</samp> for your FAT partition.
</p>

<p>
When all that is done you can use <samp>newfs_msdos disknamepartition</samp>
to create a new FAT 32 filesystem on it.
(on FreeBSD/DragonFly <samp>disknamepartition</samp> might be <samp>da0s1</samp>,
on OpenBSD/NetBSD it might be <samp>sd0i</samp> - check with <samp>disklabel</samp>)
</p>

<p>
On FreeBSD mount and safely remove it like so:
</p>

<p>
<pre>
<samp>
# <i>mkdir -p /mnt/usb</i>
# <i>mount -t msdosfs /dev/da0s1 /mnt/usb</i>
# <i>umount /mnt/usb</i>
# <i>sync</i>
</samp>
</pre>
</p>

<p>
On OpenBSD/NetBSD mount and safely remove it like so:
</p>

<p>
<pre>
<samp>
# <i>mkdir -p /mnt/usb</i>
# <i>mount /dev/sd0i /mnt/usb</i>
# <i>umount /mnt/usb</i>
# <i>eject /dev/sd0i</i>
</samp>
</pre>
</p>

<h4 id="disk_illumos">Solaris and Illumos</h4>

<p>
After you have inserted the USB stick,
you can look for its device name with the <samp>rmformat</samp> command.
It should produce an output similar to this:
</p>

<p>
<pre>
<samp>
Looking for devices...
	1. Logical Node: /dev/rdsk/c0t0d0p0
		...
		Connected Device: USB DISK 2.0 1219
		...
</samp>
</pre>
</p>

<p>
You can now edit the partition table of the disk with <samp>fdisk /dev/rdsk/c0t0d0p0</samp>.
The Illumos/Solaris <samp>fdisk</samp> program is similar to <samp>cfdisk</samp> on Linux and is straight forward to use.
Just make sure you create a <samp>D</samp> partition type and specify its size as <samp>100</samp> 
(assuming you want a single FAT 32 partition on the usb stick).
</p>

<p>
Finally create a FAT 32 filesystem on this partition with:
<samp>mkfs -F pcfs -o fat=32 /dev/rdsk/c0t0d0p0:c</samp>.
The memory stick should automatically be mounted under <samp>/media</samp>,
but you can manually mount it to a different location if you want:
</p>

<p>
<pre>
<samp>
# <i>umount /media/usbstick-name</i>
# <i>mkdir -p /mnt/usb</i>
# <i>mount -F pcfs /dev/dsk/c0t0d0p0:c /mnt/usb</i>
</samp>
</pre>
</p>

<p>
And safely remove it by:
<pre>
<samp>
# <i>umount /mnt/usb && eject /dev/dsk/c0t0d0p0</i>
</samp>
</pre>
</p>

<p>
PS:
The <i>raw</i> disk devices in Illumos/Solaris is under <samp>/dev/rdsk</samp>.
It's this device you use when formatting a disk.
When mounting a disk however you use the <i>block</i> device under <samp>/dev/dsk</samp>.
</p>

<h4 id="disk_alternatives">Alternatives to FAT</h4>

<p>
The archaic FAT filesystem from MS-DOS is awkward to use under the best of circumstances.
It cannot store any files larger than 4 Gb,
and even worse it has no concept of UNIX file permissions,
these vital security settings will be wiped when you copy them over to a FAT memory stick.
You can work around this problem by bundling your files into a <samp>tar</samp> archive.
The file permissions will then be preserved, but it is awkward...
</p>

<p>
So why are people still using this rusty old filesystem,
aren't there any better alternatives?!?
Yes and no.
A popular choice is the newer Windows filesystem NTFS since it can store files larger than 4 Gb.
Of course it to has no concept of UNIX file permissions either,
so for UNIX users this isn't a good alternative.
(And even though Linux can use this filesystem there is considerably <i>less</i> support in the UNIX world for NTFS then FAT)
Why not just use a native UNIX filesystem on the memory stick?
</p>

<p>
You can,
and in many ways it is simpler then putting a FAT filesystem on it.
Tools such as <samp>mount</samp> and <samp>newfs</samp> for instance will assume a native filesystem by default.
And of course you can store large files on it,
and keep your permission settings.
But there is a catch!
Native UNIX filesystems have virtually <i>no</i> support on other operating systems,
including different versions of UNIX!
If you happen to only use FreeBSD machines at home and at work,
then by all means,
put UFS on your memory sticks!
But don't be surprised when Solaris refuses to mount them,
even though it too uses "UFS".
The most portable UNIXy filesystem is probably old versions of the Linux EXT filesystem,
such as EXT2 or EXT3.
</p>

<p>
For better or worse,
DOS was a very simple and hugely popular operating system,
so support for its filesystem is ubiquitous.
There may not be many good alternatives to FAT,
but there are good alternatives to memory sticks,
such as
<samp>sftp</samp>, <samp>scp</samp> or <samp>sshfs</samp>,
which are all part of the <samp>ssh</samp> suit of programs.
Another excellent tool for syncing files across the network is of course <samp>rsync</samp>.
You can also set up permanent network file shares with NFS or Samba.
And of course ZFS filesystems allow you to easily share files across the network with other ZFS filesystems.
</p>

<h3 id="power">Power Management</h3>

<p>
On Linux you can use the <samp>acpi</samp> command to check your battery status and the <samp>powertop</samp> command to check which nasty interactive programs are sucking your battery dry.
You can suspend and hibernate System-D distros with <samp>systemctl suspend</samp> and <samp>systemctl hibernate</samp>.
For non-System-D disros you can probably use the <samp>pm-suspend</samp> and <samp>pm-hibernate</samp> commands from the <samp>pm-utils</samp> package.
</p>

<h4 id="power_freebsd">FreeBSD</h4>

<p>
You can check how much battery life you have left with <samp>acpiconf -i 0 | grep 'Remaining capacity'</samp>
(your battery may have a different numerical ID then "0").
If you enable apm services,
by adding <samp>apm_enable="YES"</samp> and <samp>apmd_enable="YES"</samp> to <samp>/etc/rc.conf</samp>,
you can:
</p>

<p>
<ul>
  <li><samp>acpiconf -s 1</samp>, put machine in standby mode</li>
  <li><samp>acpiconf -s 3</samp>, suspend machine</li>
  <li><samp>acpiconf -s 3</samp>, hibernate machine</li>
</ul>
</p>

<h4 id="power_openbsd">OpenBSD</h4>

<p>
If you enable the <samp>apmd(8)</samp> daemon by adding <samp>apmd_flags=""</samp> to <samp>/etc/rc.conf.local</samp>,
you can:
</p>

<ul>
  <li><samp>apm -m</samp>, list how many minutes of battery life are left</li>
  <li><samp>apm -S</samp>, put machine in standby mode</li>
  <li><samp>apm -z</samp> or <samp>zzz</samp>, suspend machine</li>
  <li><samp>apm -Z</samp> or <samp>ZZZ</samp>, hibernate machine</li>
</ul>

<p>
You can still check your battery status even if you don't have <samp>apm</samp>,
by using <samp>sysctl</samp>.
Usually something like this will work: <samp>sysctl hw.sensors.acpibat0</samp>.
Figuring out exactly how much time you have left on your battery require a bit of arithmetic,
here is a simple example script:
</p>

<p>
<pre>
<samp>
#!/bin/sh
# battery - print how much battery life is left
# usage: battery

remaining=$(sysctl hw.sensors.acpibat0 | sed 's/.*=//' | awk '/remaining/ { print $1 }')
chargerate=$(sysctl hw.sensors.acpibat0 | sed 's/.*=//' | awk '/rate/ { print $1 }')
echo $(echo "scale=2; ($remaining / $chargerate) * 60" | bc) minutes of battery life left
</samp>
</pre>
</p>

<h4 id="power_netbsd">NetBSD</h4>

<p>
Like OpenBSD,
NetBSD also uses the <samp>apmd(8)</samp> daemon for power management.
Enable it by adding <samp>apmd=YES</samp> to <samp>/etc/rc.conf</samp>.
You can now:
</p>

<ul>
  <li><samp>apm -m</samp>, list how many minutes of battery life are left</li>
  <li><samp>apm -S</samp>, put machine in standby mode</li>
  <li><samp>apm -z</samp> or <samp>zzz</samp>, suspend machine</li>
</ul>

<h4 id="power_illumos">Solaris and Illumos</h4>

<p>
As far as I know Solaris/Illumos only support suspend for SPARC architectures with <samp>sys-suspend(1)</samp>.
You can retrieve battery information with the <samp>kstat</samp> command,
but like the non-apm OpenBSD solution you need to manually work out what this information means in practice.
Here is a simple example script that prints remaining battery percentage:
</p>

<p>
<pre>
<samp>
#!/bin/sh
# battery - print how much battery life is left
# usage: battery

lastfull=$(kstat acpi_drv | awk '/last_cap/ { print $2 }')
remaining=$(kstat acpi_drv | awk '/rem_cap/ { print $2 }')
echo $(echo "($remaining * 100) / $lastfull" | bc)% remaining
</samp>
</pre>
</p>

<h3 id="security">Security</h3>

<p>
<a href="images/security.png"><img src="thumbs/security.png" title="Is any safe really safe..?"></a>
</p>

<p>
	There is no such thing as a 100% secure system,
	rather,
	it's more a question of how much effort you are willing to put into it.
	Installing a shark infested moat around your house may provide good protection against common burglars,
	but not against paratroopers for instance.
	Pros and cons must be carefully weighed.
	Private citizens usually don't need to worry about paratroopers,
	but government agencies might.
	Is the expense and maintenance worth it?
	Is the added protection worth the inconvenience of having your clumsy kids accidentally tripping into the moat?
	(this absurd analogy is more relevant to system administration - indeed parenting - then you may think).
	In that vein,
	we will not talk about over engineered security mechanisms such as ACL, SELinux, PAM, Docker and so on,
	we will only talk about security basics that all system administrators need to know,
	and know well.
	Naturally the importance of system administration is directly proportionate to the number of users on the machine.
	If you only administrate yourself,
	the following topics are merely important.
	On a production server it's a matter of life and death!
</p>

<h4 id="user_mng">Users and Groups</h4>

<p>
	The core security concept in UNIX is managing user and group <i>permissions</i> to files.
	By setting file permissions you can include or exclude users from collaborating in common projects,
	from tweaking system configurations,
	and from running certain programs.
	Consider the following example:
</p>

<p>
<pre>
<samp>
	$ <b>ls -ld $HOME</b>
	drwxr-xr-x 81 dan dan 2560 May 26 15:38 /home/dan
	$ <b>ls -l /bin/sh</b>
	-r-xr-xr-x 3 root bin 617544 Apr 19 18:16 /bin/sh
	$ <b>chmod +w /bin/sh</b>
	chmod: /bin/sh: Operation not permitted
	$ <b>cp /bin/sh $HOME/sh</b>
	$ <b>chmod +w $HOME/sh</b>
	$ <b>ls -l $HOME/sh</b>
	-rwxr-xr-x 1 dan dan 617544 May 26 15:39 /home/dan/sh
</samp>
</pre>
</p>

<p>
	The information we are interested in here is the first string of characters after the <samp>ls -l</samp> commands.
	Ignoring the very first character,
	which tells us if it's an ordinary file or a directory,
	the characters show us whether or not the file has <b>read</b>,
	<b>write</b> or <b>execute</b> permissions for the <b>owner</b>,
	the <b>group</b> and <b>everyone</b> else.
	<samp>/home/dan</samp> has owner <samp>dan</samp> and group <samp>dan</samp>,
	with permission <samp>rwxr-xr-x</samp>.
	That is,
	the <b>owner</b> dan has permission to read,
	write and execute,
	<b>rwx</b>.
	The <b>group</b> dan has permission to read and execute,
	<b>r-x</b>.
	And so does <b>everyone</b> else,
	the last <b>r-x</b>.
	So no one except the file owner in this case can edit this directory.
	But everyone can look at the files,
	and indeed make a copy of the files to their directory and freely edit the copies.
	This last point is illustrated above,
	where we first tried to give write permissions to <samp>/bin/sh</samp>
	(a rather daft thing to do!).
	This was denied because only the file owner,
	<b>root</b>,
	is allowed to do so.
	Hence we made a private copy of it,
	and then made the necessary adjustments
	(naturally the owner of a copy is whoever made the copy).
	Note the security implications here:
	Anyone who can <i>read</i> a file,
	can make a copy,
	and subsequently modify and execute the copy!
</p>

<p>
	UNIX has always been an open share and share alike environment,
	business practices of AT&T not withstanding,
	and the default file permissions reflect this somewhat.
	If we don't want to allow everyone access to snoop and copy our private files,
	we can simply run this command
	<samp>chmod 750 $HOME</samp>.
	With this set,
	our files are safe from prying eyes
	(well, not really - more on that later).
	If we want to grant other users the exclusive rights to read and copy our files,
	to work on some common project for instance,
	we can add them to the <b>dan</b> group.
	We could also have written the above command like so:
	<samp>chmod o-wx $HOME</samp>.
	This later form is perhaps easier to understand,
	it reads:
	for <b>others</b> (ei. everyone else) remove <b>write</b> and <b>execute</b> permissions.
	If we wrote <samp>ug+r</samp>,
	it would mean,
	for <b>user</b> (ei. the owner) and <b>group</b> give <b>read</b> permission.
	Often you will see the octal form however,
	which can be tricky to understand,
	but you only need to know a handful of common values to get by:
</p>

<p>
	<ul>
		<li>755 - owner has rwx, group and others have r-x</li>
		<li>644 - same as the above, but nobody has execute permissions</li>
		<li>750 - owner has rwx, group has r-x, everyone else have no access</li>
		<li>640 - same as the above, but owner and group cannot execute file</li>
		<li>600 - only the owner can read or write this file</li>
	</ul>
</p>

<p>
	Now running the command <samp>chmod 750 $HOME</samp> will indeed prevent (almost) anyone from tampering with our home directory,
	but what about all of the files <i>within</i> this directory?
	Actually,
	in this case,
	a <samp>750</samp> permission in <samp>$HOME</samp> will prevent (almost) anyone outside of the dan group to see or use files anywhere below this directory.
	But there are situations where it might be desirable to recursively set file permissions throughout a directory.
	So lets assume that we want to set a <samp>750</samp> permission for all files and directories under <samp>$HOME</samp>,
	we could do so with the following command:
	<samp>chmod -R 750 $HOME</samp>.
	But this is a very sloppy thing to do!
	The problem is that we don't really want execute permissions on ordinary files,
	except of course our custom shell scripts and assorted programs in <samp>~/bin</samp>,
	we want a <samp>640</samp> permission on plain files,
	and only a <samp>750</samp> permission for directories
	(directories NEED execute permission!).
	Setting unnecessary execute permissions on plain files will not exactly mean the end of humanity,
	but it is definitely an uncouth move,
	and it will earn you newb points!
	The correct solution would be something more akin to this:
</p>

<p>
<pre>
<samp>
	$ <b>find $HOME \( -path "*/bin/*" -prune \) -o \
	              \( \( -type d -a -exec chmod 750 {} \; \) -o \
	                 \( -type f -a -exec chmod 640 {} \; \) \)</b>
</samp>
</pre>
</p>

<p>
	It's OK to admit that the above command scares you.
	We could simplify this operation by doing it in stages,
	and actually,
	it's fine if you just lazily use <samp>chmod -R</samp> in the privacy of your own home.
	I will not tell on you.
	Sloppiness isn't really a major issue unless you are working professionally as a sysadmin.
	If that is the case,
	the above command is nothing less then job security.
	Just make sure you type this whenever your boss is looking over your shoulder.
</p>

<p>
	To illustrate user and group management,
	we create a new user (bob),
	a new group (manhat),
	assign bob to this group,
	set the new user and group as owners for some files (in /var/manhattan),
	and lastly make this directory top secret for anyone outside of this group:
</p>

<p>
<pre>
<samp>
	# <b>adduser bob</b>
	# <b>groupadd manhat</b>
	# <b>usermod -a -G manhat bob</b>
	# <b>chown -R bob:manhat /var/manhattan</b>
	# <b>chmod 770 /var/manhattan</b>
</samp>
</pre>
</p>

<p>
	You can manipulate these new user and group settings by hacking the files in <samp>/etc/passwd</samp> and <samp>/etc/group</samp> as root,
	and in the heyday of AT&T UNIX this was in fact the only way to add new users to the system.
	But this kind of wild west approach is considered bad practice today,
	its safer to use dedicated commands such as <samp>usermod</samp> and <samp>groupmod</samp>.
	To quickly check what groups you are a member of,
	type <samp>groups</samp>.
	The example above is on a Linux machine,
	annoyingly there is considerable variation in how users and groups are managed across UNIX systems.
	NetBSD and Solaris do not have <samp>adduser</samp>,
	use <samp>useradd -m bob</samp> instead.
	In FreeBSD <samp>groupadd</samp> and <samp>usermod</samp> must be prepended with <samp>pw</samp>,
	so <samp>pw groupadd manhat</samp>.
	In NetBSD and OpenBSD the usermod example would simply be
	<samp>usermod -G manhat bob</samp>.
	In Linux however this command,
	without the <samp>-a</samp> flag,
	will add bob to the manhat group,
	but remove him from any other group not mentioned.
	FreeBSD and Solaris essentially work the same way,
	but they don't have the append feature at all.
	So you either need to manually specify a full list of groups,
	eg. <samp>usermod -G adm,games,staff,manhat bob</samp>,
	or you need to construct an ungainly command such as:
	<samp>usermod -G $(awk -F: '/bob/ { printf $1 "," }' /etc/group)manhat bob</samp>
	(these examples are for Solaris,
	in FreeBSD the later would be:
	<samp>pw usermod bob -G `awk -F: '/bob/ { printf $1 "," }' /etc/group`manhat</samp>).
	There are other subtle differences and peculiarities to be aware of.
	BSD's have the unique concept of login classes,
	and Solaris has a thing about "profiles" for instance.
	As always,
	the sysadmins primary task is to read the manpages carefully!
</p>

<h4 id="sudo">To Be or Not to Be Root?</h4>

<p>
	It turns out that the secret manhattan project above isn't quite as secure as we may think.
	You see,
	UNIX systems have an all-powerful user called <b>root</b>.
	The root user can do <i>anything</i>,
	no restrictions whatsoever
	(of course the root user can set restrictions on himself,
	but he can also rescind them).
	This concept is a lot more powerful then a "system administrator",
	that you will see on some non-UNIXy systems.
	The root user is not only able to configure the system any way he wants,
	but he can engage in deep brain surgery and wanton destruction as he pleases.
	Beyond file encryption it is impossible to hide anything from root.
	Windows users may find this disconcerting,
	but in actuality they have the exact same issue,
	it's just that their "root" user is an unknown,
	plausibly evil,
	corporate entity called Microsoft
	(MacOS and Android (and Ubuntu for that matter),
	being UNIX after all,
	have a real root
	- but like Microsoft,
	they try very hard to hide this fact from the user).
</p>

<p>
	You can switch to the root user by typing the command <samp>su</samp>
	(or <samp>su -</samp> to simulate a full login),
	followed by the root password.
	By the way,
	you can use this command to switch to any user you have the password for,
	eg. <samp>su bob</samp>.
	It goes without saying that your user passwords should be a well guarded secret.
	But the <i>root</i> password is something you do not share even with your closest confidant!
	To quote Micah 7:5:
</p>

<blockquote>
<i>
	``Trust ye not in a friend,
	put ye not confidence in a guide:
	keep the doors of thy mouth from
	her that lieth in thy bosom''
</i>
</blockquote>

<p>
	With careful group management,
	it is quite possible to delegate system administration tasks to users without giving them root access.
	Users working on a web server may be part of the <samp>www</samp> group,
	in order to work on files in <samp>/var/www</samp> for instance.
	If these users also need to run some database,
	or other web server maintenance program,
	the sysadmin can just run <samp>chgrp www</samp> on these programs,
	and set permissions to 550,
	in order to allow <samp>www</samp> users to run them,
	but no one else.
	But root is so powerful,
	that the system administrator himself should not use it,
	if it can be avoided.
	To illustrate the danger,
	suppose you meant to type
	<samp>rm -rf $HOME/*</samp>
	but mistyped it:
	<samp>rm -rf $HIME/*</samp>.
	Congratulations!
	You have now deleted all files on your computer.
	Another,
	more subtle example:
	Suppose you are working in <samp>/var/www/mysite</samp>,
	and decide to delete the whole mess:
	<samp>rm -rf ../*</samp>
	Permission denied!
	<i>Oh really</i>,
	you think smugly to yourself,
	and type:
	<samp>su -</samp>,
	and then
	<samp>rm -rf ../*</samp>.
	Congratulations!
	You have now deleted all files on your computer
	(do you see why?).
	The point?
	Don't use root!
	This is where <samp>sudo</samp> comes into play.
	In it's simplest form,
	you can edit <samp>/etc/sudoers</samp>,
	and uncomment the line that says
	<samp>#%wheel ALL=(ALL) ALL</samp>,
	that is,
	remove the # sign.
	Then make sure that your user is a part of the <samp>wheel</samp> group,
	eg. <samp>usermod -a -G wheel myuser</samp> in Linux
	(some distros use <samp>sudo</samp> instead of <samp>wheel</samp> here).
</p>

<p>
	PS: Whenever you need to run some dangerous command,
	it's a good idea to check first with <samp>echo</samp>.
	For instance,
	the two disastrous file nuking commands mentioned above,
	could have easily been averted with a simple sanity check:
	<samp>echo rm -rf...</samp>
</p>


<p>
	With this in place,
	you can run <samp>sudo command</samp>,
	to execute this one command "as root".
	That still makes you disturbingly powerful of course,
	but it is marginally better then monkeying about blindly as the root user,
	at the very least it makes you open up the briefcase before you hit the red button.
	Sudo also logs any commands executed by it.
	So assuming the computer survives the attempt,
	you will know who to blame when the dust settles.
	The true beauty of <samp>sudo</samp> however,
	is that it allows you do define very fine grained privileges.
	The above line could have been
	<samp>bob 192.168.0.12 = (operator) /bin/kill, /usr/bin/lprm</samp>,
	for instance.
	Meaning that the user bob can run the commands <samp>kill</samp> and <samp>lprm</samp> on the machine 192.168.0.12,
	but only as the operator user
	(eg. <samp>sudo -u operator kill</samp>).
	You can define aliases for users and commands and things,
	in order to administrate this.
	If we defined <samp>Host_Alias	CSNETS = 192.168.0.12, 128.138.204.0/24, 128.138.242.0</samp> for example,
	we could have written CSNETS instead of 192.168.0.12,
	to allow bob access to this list of machines.
</p>

<p>
	PS: Not all variants of UNIX come with sudo by default,
	and some have their own sudoy kind of commands
	(eg. <samp>pfexec</samp> in Solaris and <samp>doas</samp> in OpenBSD).
	But all UNIX systems have sudo in their repositories at least.
</p>

<h4 id="ssh">Remote Connections</h4>

<p>
	About a thousand years ago,
	when vikings roamed the sea and pillaged unsuspecting Monasteries,
	people used <samp>telnet</samp> to login to their remote UNIX machines.
	It was truly a barbaric time when "security" was an unknown concept.
	Today of course we use <samp>ssh</samp> to connect safely,
	and civilly,
	to our remote machines.
	But simply having <samp>ssh</samp> will not magically make the world around you safe.
	You need to use this tool <i>correctly</i>.
	In a word,
	this means:
	disable password authentication.
</p>

<p>
	By default,
	an ssh server will accept a password login from anyone who has an account on the machine.
	Naturally this has to be the default,
	it would be impossible to set up a remote server otherwise.
	But the very first thing you should do on your shiny new server,
	is to set up public key authentication and then DISABLE password authentication!
	Passwords are a good way to protect your laptop from benevolent coworkers,
	it is NOT a safe way to protect your server out there on the hostile internet.
	There exists a network of bots on the web,
	dubbed the "Hail Mary Cloud",
	that will systematically probe any ssh server.
	This cloud will try to login to your server a few times from one ip address,
	then try again with another ip,
	and so on and so on...
	If you allow password authentication on your remote ssh server,
	it will get compromised,
	its simply a matter of time.
</p>

<p>
	The answer to this problem is public keys.
	To understand why,
	we can use a simple analogy:
	Suppose you have set up a secret pirate club in downtown New York,
	with a big flashy neon sign that says
	"secret password required upon entry!"
	Well,
	daily you'll be pestered with kids trying to guess the password,
	and eventually one of them will get it right,
	before long half of New York City will enter your top secret pirate den.
	The point?
	Use keys.
	Anyone who now wants to sneak into your club,
	must first accost a pirate and steal his key.
	Naturally,
	the bouncer should still ask for a secret password,
	for added security against such an event.
	To create an ssh key on your laptop run <samp>ssh-keygen</samp>.
	Once this is done,
	copy your key over to the server with:
	<samp>cat ~/.ssh/id_rsa.pub | ssh myserver 'cat >>~/.ssh/authorized_keys'</samp>.
	When you now log on to your server with <samp>ssh</samp>,
	it should say: <samp>Enter passphrase for key...</samp>.
	When you have verified in this way that your key is working,
	go ahead and disable password authentication on your ssh server.
	Edit <samp>/etc/ssh/sshd_config</samp>,
	and add these options:
</p>

<p>
<pre>
<samp>
	ChallengeResponseAuthentication no
	PasswordAuthentication no
	PubkeyAuthentication yes
</samp>
</pre>
</p>

<p>
	From the server you can copy your <samp>authorized_keys</samp> file to other ssh servers with:
	<samp>ssh-copy-id</samp>,
	to allow your laptop to access these remote machines using the same key.
	<i>However</i>,
	you want to create unique keys for <i>each</i> physical laptop/workstation that you are using.
	It is possible to use one key for multiple machines,
	just as it is possible to use one physical key for many houses,
	but it is very dumb thing to do!
	It is also possible to set up your ssh key without requiring a passphrase.
	This is actually <i>slightly</i> more secure than using password authentication,
	but it is nevertheless <i>bad</i> practice.
	The passphrase isn't used to authenticate against the server,
	the key is used for that,
	rather,
	the passphrase is used to decrypt a key <i>locally</i>.
	The reason for this security measure is to protect your key in case it is stolen.
	If your laptop is compromised,
	and they are easily compromised,
	the intruder can use unencrypted keys to access your remote servers.
	If your keys are encrypted with a passphrase however,
	the keys are of no use to the intruder.
</p>

<p>
	Once you have enabled key authentication,
	you can simplify things a bit further by using an ssh agent.
	On the console,
	you can type <samp>ssh-agent sh</samp>
	(or use whatever shell you prefer),
	and then <samp>ssh-add</samp>.
	You will be asked to type in your passphrase.
	Once done,
	the decrypted ssh keys will be saved in memory,
	and subsequently used whenever you run an <samp>ssh</samp> command.
	So in effect,
	you type the passphrase once,
	and use <samp>ssh</samp> throughout the day without typing in any passwords.
	This convenient approach is <i>not safe</i> if you share your computer with multiple users.
	Before taking a break at work,
	type <samp>ssh-add -D</samp> to flush the keys,
	then retype <samp>ssh-add</samp> when you get back from lunch
	(and obviously - shut down the computer before you leave for the day).
</p>

<p>
	PS: Unfortunately the method of starting an ssh agent varies considerably between desktop environments and login managers,
	not to mention Windows.
	So consult your operating systems/desktops documentation,
	if you want to set up an ssh agent outside of the text console
	(also,
	the <samp>ssh-agent</samp> command must be executed on each virtual console you wish to use it on).
	To be clear: it's not very hard to set up,
	but it's hard to <i>document</i>,
	since it varies so.
</p>

<p>
	You can do a <i>lot</i> of stuff with ssh.
	You can use it to secure network traffic that isn't otherwise encrypted.
	You can do remote desktop work with it.
	You can set up your own private VPN with ssh,
	and you can mangle the network in all kinds of other interesting ways.
	These topics are well outside the scope of this article,
	if you are interested,
	check out <i>SSH Mastery</i> by Michael W. Lucas.
	Lucas has a wide array of other high quality books that security minded UNIX sysadmins will likely find both beneficial and humorous.
	Some suggestions are: <i>Sudo Mastery</i>,
	<i>PAM Mastery</i>,
	<i>PGP & GPG</i> and many others.
	Check out
	<a href="https://mwl.io">his website</a>
	if you are interested.
</p>

<h4 id="passwords">Passwords</h4>

<p>
<a href="images/password_strength.png"><img src="thumbs/password_strength.png" title="As always, turn to XKCD for wisdom."></a>
</p>

<p>
	Like SSH,
	things are not magically secure just because you have a password.
	You need to use passwords <i>correctly</i>.
	There are two steps involved.
	First,
	you want long passwords that isn't easy to break.
	A good way is to find some obscure text that is very unique to you,
	an old Christmas card from a long gone relative,
	a really obscure magazine from the attic of your grandfather,
	or just some random sentence that only you can understand.
	Do not use short passwords,
	however obfuscated,
	nor anything from pop culture.
	"He's dead Jim" or "p455w0rd" are <i>not</i> safe passwords!
	"Hyesterettsjustitiariussjefsassistenten e en bondeknlbavianbajas fra Hlogalandbispedmmes ytterste gudsfrlatte feskevr!!!"
	<a text="Loosely translated: "The Supreme Justices's Chief Assistant is an ape scalawag bumpkin from the remotest godforsaken fishing village in the Halogaland parish">*</a>
	is a resonably good password
	(and easily remembered if you happen to be a Northern-Norwegian).
</p>

<p>
	Secondly,
	and <i>most importantly</i>,
	use different passwords for different things.
	Do NOT use the same password over and over again
	(and for the love of Mike - do NOT write down your passwords on post-it notes!).
	<i>But I cannot remember a whole bunch of passwords!</i>
	you may think.
	Of course you can't,
	nobody can.
	If you are trying to remember your passwords,
	<i>you are doing it wrong!</i>
	Use a password manager.
	A password manager is like a secure post-it note.
	It requires a password to open,
	and once opened,
	you can freely read and edit a list of your passwords.
	So in effect,
	you use one password to access all your other passwords.
	If you are working on a graphical desktop,
	I recommend that you use KeePass,
	or one of it's variants (eg. KeePassXC).
	If you are working on the console,
	you can easily
	<a href="#password_mng">make your own password manager</a>.
</p>

<h3 id="interactive">Making Things Interactive</h3>

<p>
Another problem with using the console as a desktop is that things aren't interactive,
there's no menu for finding applications or clickable icons for launching your favorite programs,
even just a flippin progress bar for your <samp>cp</samp> would be nice!
Settle down,
there are solutions for all of this and more...
</p>

<h4 id="shortcuts">Creating Shortcuts</h4>

<p>
Although you cannot create graphical icons for launching a program in the console,
you certainly can create shortcuts.
For example,
you can add this to your <samp>~/.profile</samp>
(or <samp>~/.bashrc</samp> if you plan to use them from X):
</p>

<p>
<pre>
<samp>
alias web=links
alias edit=nano
alias files=mc
alias play=mplayer
alias picture=fbi
alias game=myman
</samp>
</pre>
</p>

<p>
You can now edit files by typing <samp>edit</samp>,
play video and music with <samp>play</samp>,
view your files with <samp>files</samp>,
and so on.
If you are having trouble remembering your own aliases,
just run the command <samp>alias</samp> to see a list of them.
</p>

<p>
Aliases are also useful for running a command with a default set of flags,
for example I usually set <samp>alias lynx='lynx -accept_all_cookies -assume_charset=utf8 -tagsoup'</samp>,
which makes the console browser <samp>lynx</samp> behave nicer.
Aliases are nice for oneliners,
but for serious automation you need shell scripts.
A good tip is to place this is your <samp>~/.profile</samp>
(or other appropriate place):
<samp>export PATH=$HOME/bin:$PATH</samp>.
This line adds <samp>$HOME/bin</samp> to your list of default program paths,
you can now write your shell scripts in this directory,
and launch them from anywhere.
</p>

<h4 id="menu">Creating Menus</h4>

<p>
Serious powerusers <i>do not</i> use menus of course,
like an efficient dictator in a banana republic,
he simply states his will in clear unmistakable language and watches it happen,
he does not ask to see the <i>menu</i> first!
But suppose you are a sysadmin in a company,
and the above set of aliases are just too hard for one of your newb colleagues to remember.
The only way this poor fellow can manage to launch an application is if he can write the command <samp>thing</samp>,
and then select his desired application from a menu.
Can you still force this <s>luser</s> user to use the console?
</p>

<p>
Certainly,
if all you need is a static menu,
then <samp>select</samp> might do the trick
(PS: not all UNIX versions of <samp>sh</samp> support <samp>select</samp> - and not all versions of select behave in the same manor):
</p>

<p>
<pre>
<samp>
#!/bin/sh
# thing - launch applications
# usage: thing

selectfile(){
    echo -n "File: "
    read file
    if [ ! -f "$file" ]; then
        echo "Error: file doesn't exist!"
        exit
    else
        exec "$1" "$file"
    fi
}

select prog in Web Edit Files Play Picture Game; do
    case $prog in
        Web)    echo -n "URL: "
                read url
                exec links $url
                ;;
        Edit)   selectfile nano ;;
        Files)  exec mc ;;
        Play)   selectfile mplayer ;;
        Pict*)  selectfile cacaview ;;
        Game)   exec vitetris ;;
        *)      echo "Please choose a number!"
    esac
done
</samp>
</pre>
</p>

<p>
You can also easily write a welcome message that all users will see as they login to the system,
just by putting the text into <samp>/etc/motd</samp>
(motd means "message of the day").
If you just want to give a specific user a message as he logs in,
you can just put something like this is his <samp>~/.profile</samp> (or <samp>~/.bashrc</samp>):
<samp>cat /path/to/some/instructions</samp>,
or even just:
<samp>echo to do something dear newbie type "thing" without the quote marks.</samp>
(admittedly,
the kind of user who needs such a menu,
would have a hard time understanding how to type "thing" without the quote marks...)
</p>

<p>
<a href="https://pspodcasting.net/images/dan/blog/2018/gui.png"><img src="thumbs/gui.png" title="thanks to dialog you don't need to run windows to have a stupid gui!"></a>
</p>

<p>
If you want a more "GUI-like" experience though,
<samp>dialog</samp> is your friend.
This program can create a large set of standard GUI widgets with ncurses graphics,
such as radiolists,
progressbars,
file and calendar selections etc...
You can even play Microsoft and create a whole chain of "are you sure",
"are you *REALLY* sure" yes-or-no boxes to make that professional vibe and annoy your users to no end.
The above example in <samp>dialog</samp> would be:
</p>

<p>
<pre>
<samp>
#!/bin/sh
# thing - launch applications, using ncurses
# usage: thing

tmp=/tmp/menu
while true; do
    dialog --menu "Startup Menu" 0 0 0 1 "Web" 2 "Edit" 3 "Files" 4 "Play" 5 "Picture" 6 "Game" 2> $tmp
    if [ $? = 1 ]; then
        exit
    fi

    selectfile(){
        dialog --title "Files" --fselect $HOME/ 0 0 2>$tmp
        if [ $? = 0 ]; then
            file=$(cat $tmp)
            exec "$1" "$file"
        fi
    }

    prog=$(cat $tmp)
    case $prog in
        1)  dialog --title "URL" --inputbox "Enter website address:" 0 0 2> $tmp
            if [ $? = 0 ]; then
               url=$(cat $tmp)
               exec links $url
            fi
            ;;
        2)  selectfile nano ;;
        3)  exec mc ;;
        4)  selectfile mplayer ;;
        5)  selectfile cacaview ;;
        6)  exec vitetris ;;
    esac
done
</samp>
</pre>
</p>

<h4 id="progress">Progressbars and Interactive Pipes</h4>

<p>
Most UNIX console programs follow "the rule of silence".
This rule simply states that the users time and concentration is valuable,
so do your work silently and only report back if the task is complete or if something went horribly wrong,
don't pester him with trivia.
To be frank,
this concept is very hard for a casual desktop user even to understand.
You assume that my time and concentration is <i>valuable</i>,
what kind of lame excuse is that,
how dare you give me the silent treatment?!?
Imagine shouting at a respectful butler for delivering your letters like you asked him to,
<i>without</i> calling every other second to report how many steps he had taken towards the mailbox!
Truthfully,
modern computer systems have become little more then narcissistic training boxes.
Experienced UNIX users actually enjoy a system that doesn't constantly second guess them or bother them with irrelevant information.
The tranquility and peace of mind that the rule of silence provides is in fact one of the main benefits of using UNIX.
Sometimes however you need to know how a command is progressing,
is there a progressbar or something for the console?
</p>

<p>
Yes.
First though,
if you are lucky enough to use FreeBSD,
you can hit <kbd>Ctrl</kbd> + <kbd>t</kbd> at any time,
to see how a program is progressing.
GNU (read Linux) utilities does not have this feature,
but there is a program,
appropriately named <samp>progress</samp>,
which will tell you the progress of standard coreutils programs,
such as <samp>cp</samp> or <samp>mv</samp>.
</p>

<p>
<a href="https://pspodcasting.net/images/dan/blog/2018/console.png"><img src="thumbs/console.png" title="the UNIX console - notice the absurd lack of distractions!"></a>
</p>

<p>
You can also create your own progressbar with <samp>pv</samp> (pipe viewer),
it functions like <samp>cat</samp>,
but reports its progress.
So <samp>pv bigfile > bigfilecopy</samp>,
will copy the file with a progressbar.
You can also stick <samp>pv</samp> in the middle of a pipeline and see how it's progressing,
eg. <samp>cat file | pv -s $(du file | awk '{ print $1 }') | nc -w 1 somewhere.com 3000</samp>.
In this example we need to tell <samp>pv</samp> how large the file is with <samp>-s $(du file | awk '{ print $1 }')</samp>.
Without this <samp>pv</samp> will still report write speed,
but it will not know when the job is nearing it's completion.
</p>

<p>
You can also manipulate pipelines interactively in other ways.
For example the <samp>percol</samp> program (Linux only) will let you interactively select elements from the pipe input and send it down the line,
eg. <samp>ls | percol | du -h</samp>.
A somewhat similar program from the <samp>moreutils</samp> package,
<samp>vipe</samp>,
which is also available on non-Linux systems,
will let you edit the input with <samp>vi</samp>,
once you exit the editor,
the modifications will be sent down the pipe.
</p>

<h4 id="auto">Autocompletion</h4>

<p>
You must know how to read and write in order to use the console,
but contrary to popular belief,
you don't need to write much.
Use the <samp>tab</samp> key to auto-complete filenames.
So don't type <samp>cd /really-long-AND-obscure_path/to_my_file-SomeWhErE</samp>,
just type <samp>cd /r</samp> then hit <samp>tab</samp>,
if it doesn't complete fully,
hit <samp>tab</samp> again to get a list of alternative matching files,
type one or two letters more and hit a final <samp>tab</samp>.
You have now typed a total of 9 keys,
instead writing out all the 53 characters by hand!
You should also learn to use some basic regex:
Don't run the command <samp>rm "Aqua/I'm A Barbie Girl.mp3" "Aqua/Doctor Jones.mp3"</samp>,
run <samp>rm Aqua/*.mp3</samp>
(or better yet <samp>rm -rf Aqua && echo Good Riddance!</samp>).
</p>

<p>
The <samp>bash-completion</samp> package will let your <samp>bash</samp> shell auto-complete more then just filenames.
But for serious auto-completion power I recommend switching your default shell to <samp>zsh</samp>
(And for your grandma I recommend <samp>fish</samp>).
</p>

<h4 id="fun">Having Fun</h4>

<p>
Alright,
you're thinking,
so you can do quite a lot of functional things with the console,
but to be honest:
The reason I still want to use the desktop,
is because it is fun!
I want to goof around with
<a href="#framebuffer">wallpapers</a>,
<a href="#misc">screensavers</a>,
<a href="#game">games</a>,
<a href="#desktop_console">3D desktop cubes</a>,
watch <a href="#video">youtube</a> videos,
and you know what,
I really enjoy constantly <a href="#desktop_console">resizing my windows</a>.
Seriously,
I get a kick out of it.
You just can't do that in the console!
Oh really?
Check out the links in the above paragraph...
If on the other hand,
you just want to go on the web,
keep reading :)
</p>

<h2 id="web">The Web</h2>

<h3 id="connect">Connecting to the Internet</h3>

<p>
Running <samp>ifconfig</samp> is a quick way to check your network settings,
pay particular attention to your network card names.
In Linux the wired network card is often called <samp>eth0</samp>,
and the wireless card <samp>wlan0</samp>,
but not always.
Other UNIX operating systems use different names.
Pinging a website
(eg. <samp>ping www.wikipedia.org</samp>)
is a quick way to check that your online,
but remember that this will usually not work from a virtual machine.
Connecting to the web over a wired network is often done with <samp>dhclient eth0</samp> or <samp>dhcpcd eth0</samp>.
</p>

<p>
You may be using a version of Linux that doesn't have <samp>ifconfig</samp>,
in that case you need to use the <samp>ip</samp> command instead.
Here is a quick ip to ifconfig cheat sheet:
</p>

<p>
<pre>
ifconfig			ip a
ifconfig eth0 up		ip link set eth0 up
ifconfig eth0 down		ip link set eth0 down
ifconfig eth0 add 10.0.0.1/24	ip a add 10.0.0.1/24 dev eth0
ifconfig eth0 del 10.0.0.1/24	ip a del 10.0.0.1/24 dev eth0
</pre>
</p>

<p>
How about connecting to a wireless network?
On Linux the easiest way to do this is usually with <samp>nmcli</samp>,
a command line front-end to NetworkManager,
which should be available by default.
You can list available networks: <samp>nmcli dev wifi list</samp>,
connect to a network: <samp>nmcli dev wifi con mynetwork password mypassword</samp>.
</p>

<h4 id="wifi">Wifi without NetworkManager</h4>

<p>
If you aren't using Linux,
or your version of Linux doesn't have NetworkManager
(or you don't <i>want</i> to use it),
you can probably use <samp>wpa_supplicant</samp> to connect to your wifi.
First write a default configuration file in <samp>/etc/wpa_supplicant.conf</samp>:
</p>

<p>
<pre>
<samp>
network={
	ssid="my home network"
	scan_ssid=1
	key_mgmt=WPA-PSK
	psk="mypassword"
}
</samp>
</pre>
</p>

<p>
With this in place we can make our connection.
First make sure your wifi card is activated: <samp>sudo ifconfig wlan0 up</samp>.
Then start wpa_supplicant: <samp>sudo wpa_supplicant -B -c/etc/wpa_supplicant.conf -iwlan0</samp>
And finally request an ip address form the wireless router: <samp>dhclient wlan0</samp>.
You should now be connected!
</p>

<p>
If you only plan on ever connecting to a single wireless network,
then this is enough.
(actually in such a case you should probably invest in an ethernet cable...)
But if you need to connect to wireless networks arbitrarily,
manually editing the wpa_supplicant.conf file every time is tedious.
You can write the following <samp>wifi</samp> script to handle things automatically:
</p>

<p>
<pre>
<samp>
#!/bin/sh
# wifi - connect to a wifi network
# usage: wifi network password
wlan=${wlan:-wlan0}
sed -i -e "s/ssid=.*/ssid=$1/" -e "s/psk=.*/psk=$2/" /etc/wpa_supplicant.conf
ifconfig $wlan up
wpa_supplicant -B -c/etc/wpa_supplicant.conf -i$wlan
dhclient $wlan
</samp>
</pre>
</p>

<p>
You can now run the script: <samp>sudo wifi 'my home network' password</samp>.
(or <samp>wlan=wlan1 sudo wifi 'my home network' password</samp> if your device isn't <samp>wlan0</samp>)
There are a few problems with this script though:
The script does not check for errors,
such as badly written arguments.
Running <samp>sudo wifi my home network password</samp> would fail without giving you any obvious error messages 
(do you see why?).
It doesn't list available wifi networks,
for that you probably need <samp>iwlist</samp>.
And it stores your password as plain text,
you should probably use <samp>wpa_passphrase</samp> to encrypt it.
(you may also need to use <samp>dhcpcd</samp> instead of <samp>dhclient</samp>).
All of these issues can be addressed,
but I leave that as an exercise for the reader.
</p>

<p>
As a side note,
you should never configure your wireless router to accept connections without a password,
or to use WEP encryption,
which is more or less the same thing.
If you <i>do</i> need to connect to a WEP router,
use <samp>iwconfig</samp> not <samp>wpa_supplicant</samp>.
</p>
<p>
<b>Update:</b>
Actually it turn out that you shouldn't use 
<a href="https://www.theguardian.com/technology/2017/oct/16/wpa2-wifi-security-vulnerable-hacking-us-government-warns">wpa/wpa2</a> either... 
hm...
Maybe IP over 
<a href="https://en.wikipedia.org/wiki/IP_over_Avian_Carriers">carrier pigeons</a>
is the safe option?
Of course that method has security concerns as well,
such as cats...
</p>

<p>
You can use a password manager to store network passwords,
and use a simple script to automatically search this encrypted database and connect to your network,
as discussed in the
<a href="#password">password manager</a>
section below.
</p>

<h4 id="wifi_freebsd">FreeBSD and DragonFly BSD</h4>

<p>
With the exception of OpenBSD,
all the BSD's use wpa_supplicant to connect to wireless networks,
as described above.
Although the mechanism is basically the same,
some of the particulars vary.
The first issue in FreeBSD is simply enabling the wireless network card.
You can run <samp>sysctl net.wlan.devices</samp> to get the name of your card,
it might be something like <samp>iwm0</samp>.
You can get more information by analyzing the output of <samp>pciconf -lv</samp>,
or just by running <samp>dmesg | grep Wireless</samp>.
This last command might return something like this:
</p>

<p>
<pre>
<samp>
iwm0: <Intel(R) Dual Band Wireless AC 8265> mem 0xec000000-0xec001fff irq 18 at device 0.0 on pci5
</samp>
</pre>
</p>

<p>
Now that we know we are using an Intel iwm 8265 wireless network card,
we can go ahead and configure FreeBSD to load up the correct firmware and other necessities at boot time,
by adding these values to <samp>/boot/loader.conf</samp>:
</p>

<p>
<pre>
<samp>
if_iwm_load="YES"
iwm8265fw_load="YES"
legal.intel.ipw.license_ack=1
legal.intel.iwm.license_ack=1
legal.intel.iwi.license_ack=1
wlan_wep_load="YES"
wlan_ccmp_load="YES"
wlan_tkip_load="YES"
</samp>
</pre>
</p>

<p>
Boy,
that was a lot of work!
From here though,
things get easier.
The next step is to write a <samp>/etc/wpa_supplicant.conf</samp> file for your wireless network,
it might look something like this:
</p>

<p>
<pre>
<samp>
network={
    ssid="mynetwork"
    psk="mypassword"
}
</samp>
</pre>
</p>

<p>
Finally,
we can configure the system to start wpa_supplicant at boot time:
</p>

<p>
<pre>
<samp>
# <i>echo wlans_iwm0="wlan0" >> /etc/rc.conf</i>
# <i>echo ifconfig_wlan0="WPA DHCPSYNC" >> /etc/rc.conf</i>
# <i>service netif restart</i>
</samp>
</pre>
</p>

<p>
You should now be connected to the wireless network!
You can switch to another wireless network manually by editing <samp>/etc/wpa_supplicant.conf</samp>,
and then run <samp>service netif restart</samp> again.
But we can also make a short script that automates this:
</p>

<p>
<pre>
<samp>
#!/bin/sh
# wifi - connect to a wifi network (FreeBSD edition)
# usage: wifi network password
sed -i '' -e "s/ssid=.*/ssid=$1/" -e "s/psk=.*/psk=$2/" /etc/wpa_supplicant.conf
service netif restart
</samp>
</pre>
</p>

<p>
PS: The process of connecting to a wireless network in DragonFly BSD is exactly the same,
with one exception:
The DragonFly kernel is preconfigured to use any wireless devices currently supported,
so just write your <samp>/etc/wpa_supplicant.conf</samp> and add a few values in </samp>/etc/rc.conf</samp>,
and you are good to go!
</p>

<h4 id="wifi_netbsd">NetBSD</h4>

<p>
Setting up a wireless network in NetBSD is easy peasy,
compared to FreeBSD at least ;)
First write a configuration file for your wireless network in <samp>/etc/wpa_supplicant.conf</samp>,
it might look something like this:
</p>

<p>
<pre>
<samp>
ctl_interface=/var/run/wpa_supplicant
ctl_interface_group=wheel
network={
	ssid="mynetwork"
	psk="mypassword"
}
</samp>
</pre>
</p>

<p>
Now add the following values to <samp>/etc/rc.conf</samp>
(this example assumes your network card is called "iwn0",
it may be called something else):
</p>

<p>
<pre>
<samp>
wpa_supplicant_flags="-i iwn0 -c /etc/wpa_supplicant.conf"
dhcpcd=YES
</samp>
</pre>
</p>

<p>
Now reload network settings with <samp>/etc/rc.d/wpa_supplicant reload</samp>,
and you should be connected.
To change to a different wireless network,
you can edit <samp>/etc/wpa_supplicant.conf</samp>,
and run <samp>/etc/rc.d/wpa_supplicant reload</samp> again.
Naturally you can automate this,
here is a NetBSD version of the above wifi script:
</p>

<p>
<pre>
<samp>
#!/bin/sh
# wifi - connect to a wifi network (NetBSD edition)
# usage: wifi network password
sed -i -e "s/ssid=.*/ssid=$1/" -e "s/psk=.*/psk=$2/" /etc/wpa_supplicant.conf
/etc/rc.d/wpa_supplicant reload
</samp>
</pre>
</p>

<h4 id="wifi_openbsd">OpenBSD</h4>

<p>
If you feel confused after reading the above sections,
you should be!
It is worth mentioning that <i>OpenBSD</i> is the only operating system in the UNIX world that connects to a wireless network in a sensible way:
<samp>ifconfig iwn0 nwid 'my home network' wpakey mypassword</samp>
followed by
<samp>dhclient iwn0</samp>.
And how do you scan for wireless networks?
<samp>ifconfig iwn0 scan</samp>.
This last command also works for the other BSD's btw.
(<samp>iwn0</samp> is a typical wireless card name in OpenBSD,
and <samp>em0</samp> is a typical ethernet card name,
but your devices may have different names).
Other operating system developers could learn a <i>lot</i> from the OpenBSD weirdos :)
</p>

<h4 id="wifi_illumos">Solaris and Illumos</h4>

<p>
As for Illumos it has it's own "NetworkManager" called NWAM,
which if running will try to connect you to any known wifi or ethernet links automatically.
You can also scan for wireless networks with <samp>dladm scan-wifi</samp> and connect to one like so: <samp>dladm connect-wifi -e 'my home network' wpi0</samp>
(<samp>wpi0</samp> is a typical wireless card name in Solaris,
and <samp>e1000g0</samp> is a typical ethernet card name,
but your devices may have different names).
</p>

<p>
It is possible to disable NWAM and use ifconfig manually.
For instance,
these commands will disable NWAM and manually request an ip address from your DHCP server
(to switch back to NWAM, disable "default" and enable "nwam"):
</p>

<pre>
<samp>
svcadm disable network/physical:nwam
svcadm enable  network/physical:default
ifconfig wpi0 dhcp
</samp>
</pre>

<h3 id="browsing">Browsing</h3>

<p>
The modern web browser is a beast,
and not in a good way...
In fact Firefox has about 25 million lines of code,
and is bigger then Linux kernel and the entire KDE4 suit of applications combined
(as of 2019, as time goes by these statistics will only grow worse)!
Expecting something like this to work in the text-based UNIX console is hopelessly unrealistic.
Sadly this is one area where the console does not,
and cannot,
impress.
</p>

<p>
Having that said there are a number of internet browsers available for the console.
The classic choice is <samp>lynx</samp>,
its a bit like <samp>vi</samp> in that you need to learn a whole set of key-bindings before it becomes useful.
But like <samp>vi</samp> it is very fast and efficient once learned.
You can check these key bindings by starting <samp>lynx</samp> and typing <kbd>?</kbd>.
A more user-friendly alternative is <samp>links</samp>.
It has a nice drop down menu accessible with <kbd>Esc</kbd>.
</p>

<p>
<i>PS:</i>
none of these browsers support anything like javascript or flash!
</p>

<p>
For a more graphical experience (Linux only) you can run <samp>links -g</samp>,
if the
<a href="#framebuffer">framebuffer</a>
has been configured.
<samp>w3m</samp>
is also capable of rendering images in the framebuffer
(in debian you want the <samp>links2</samp> and <samp>w3m-image</samp> packages).
</p>

<p>
Perhaps the most impressive framebuffer browser is <samp>NetSurf</samp>,
it even has some rudimentary javascript support
(in debian install <samp>netsurf-fb</samp>).
In many distros this package has a serious bug:
you can work around it by copying some font files:
<samp>cp /usr/share/fonts/truetype/dejavu/* /usr/share/netsurf</samp>
A graphical browser in a Linux console sure looks impressive,
but don't expect them to replace Firefox or Chrome anytime soon...
</p>

<p>
<a href="images/web.png"><img src="thumbs/web.png" title="There are cli browsers, but don't expect anything like Firefox or Chrome..."></a>
</p>

<h3 id="webapps">Web Apps</h3>

<p>
Do not be too quick to dismiss <samp>lynx</samp> though, 
even if many sites will not work and you find the whole experience boring!
The big graphical browsers out there are buggy,
bloated and more often then not,
boneheaded!
<samp>lynx</samp> on the other hand is an invaluable tool for debugging your web server.
It often helps to see what your website looks like in pure HTML,
blind people using screen readers,
for instance,
will often see you site exactly as <samp>lynx</samp> presents it
(shame on the web developers who discriminate blind folk and UNIX nerds alike!).
This venerable old tool also does a supreme job of rendering sites as pure text.
So if you want to print out the Wikipedia article about Slackware for instance,
you could run the command:
<samp>lynx -dump https://en.wikipedia.org/wiki/Slackware | lpr</samp>.
</p>

<h4 id="weatherapp">Example 1: A Weather App - using Lynx</h4>

<p>
Still not convinced?
Here is a short demonstration of a simple web app printing todays weather:
</p>
<p>
<pre>
<samp>
$ <i>lynx -dump http://weather.yahoo.com/united-states/illinois/chicago-2379574/</i>
...
Current conditions as of 1:54 pm EDT
Mostly Cloudy

	Feels Like:
		32 F


	Barometer:

		30.13 in and rising
...
$ <i>cat sedcond</i>
/IL, United States/{
n
p
}
$ <i>cat sedtemp</i>
/Feels Like/{
p
}
$ <i>cat weather</i>
#!/bin/bash
# weather - extract the current weather for Chicago, IL
# usage: weather

URL="http://weather.yahoo.com/united-states/illinois/chicago-2379574/"
LYNX=$(which lynx)
TMPFILE=$(mktemp tmpXXXXXX)
$LYNX -dump $URL > $TMPFILE
conditions=$(cat $TMPFILE | sed -n -f sedcond)
temp=$(cat $TMPFILE | sed -n -f sedtemp | awk '{print $4}')
rm -f $TMPFILE
echo "Current conditions: $conditions"
echo The current temp outside is: $temp
$ <i>./weather</i>
Current conditions: Mostly Cloudy
The current temp outside is: 32 F
</samp>
</pre>
</p>

<p>
Of course yahoo might change their website and break our script.
The point here is to understand the potential of <samp>lynx</samp>.
Once you convert a webpage to pure text,
you can feed it to the standard UNIX tools such as <samp>sed</samp>,
<samp>awk</samp>,
<samp>bc</samp>,
etc...
</p>

<h4 id="dailyapp">Example 2: Daily Motivational's - using wget</h4>

<p>
Let's explore another example.
This Web App prints daily quotations from 
<a href="http://www.quotationspage.com">quotationspage.com</a>.
It checks if the URL is valid or not,
and writes a download log in <samp>/tmp/quote.log</samp>.
You can run this script as a daily cron job,
and configure your shell to print the daily quote,
if you want:
</p>

<p>
<pre>
<samp>
#!/bin/sh
# dquote - download daily quote to /tmp/daily_quote.txt
# usage: dquote

quote_url=www.quotationspage.com/qotd.html
check_url=$(wget -nv --spider $quote_url 2>1&)

if (echo $check_url | grep -s '*error404*'); then
	echo "Bad web address"
	echo "$quote_url invalid"
	echo "Exiting script..."
	exit
fi

wget -o /tmp/quote.log -O /tmp/quote.html $quote_url

sed 's/<[^>]*//g' /tmp/quote.html |
grep "$(date +%B' '%-d,' '%Y)" -A2 |
sed 's/>//g' |
sed '/&nbsp;/{n ; d}' |
sed 's/&nbsp;//g' |
tee /tmp/daily_quote.txt > /dev/null
exit
</samp>
</pre>
</p>

<p>
Much of the details here has to do with cleaning up the HTML code,
and printing only the text we want.
If your having trouble following the logic here,
I suggest you do the steps manually,
one by one,
and analyze how it transforms the output.
</p>

<h4 id="smsapp">Example 3: Sending SMS - using curl</h4>

<p>
<samp>wget</samp> is great for retrieving data from the web,
but it's cousin <samp>curl</samp> can also <i>send</i> data.
In this example we use curl to send an SMS message to our phone
(PS: This will only work within the US)
</p>

<p>
<pre>
<samp>
#!/bin/sh
# sms - send an sms
# usage: sms number message...

phone=$1
shift
SMSrelay_url=http://textbelt.com/text

curl -s $SMSrelay_url -d \
number=$phone \
-d "message=$@" > /dev/null
exit
</samp>
</pre>
</p>

<p>
If you happen to have a boring staff meeting in 30 minutes,
you can send this message to your phone in 35 minutes,
and thus get a convenient excuse to leave,
like so:
<samp>at -f 'sms 3173334444 Emergency - need you in the office now!' Now + 35 minutes</samp>
</p>

<h4 id="chatapp">Example 4: A Chat Client - using netcat</h4>

<p>
As the name suggests,
netcat (or just nc),
is really a "cat" for networks.
It's an invariable tool for testing and debugging your servers.
In this example we are going to recreate the classic UNIX talk command,
a dead simple chat program,
using netcat on both machines.
On the first machine run <samp>nc -l 1234</samp>,
then on the second run <samp>nc <ip_address> 1234</samp>.
That's it!
</p>

<p>
Just as the old talk command our chat program is crude beyond words,
it does not identify who is talking,
and the text is garbled if both users write at the same time.
The old UNIX talk convention was that the user who initiated the conversation starts typing and ends with "(O)" for over,
then the second user responds and ends with "(O)",
and so on,
until someone finally ends the conversation with "(OO)" for over and out.
Of course it is possible to program a much more elaborate chat client using netcat,
that identifies the users and handles simultaneous input,
but that would kind of spoil the fun now wouldn't it ;)
</p>

<p>
There is a whole host of web tools available for the console that we haven't covered.
But I hope these examples have wet your appetite,
and perhaps demonstrated how useful the console tools can be on the modern web.
At least you don't have to learn some horrid javascript framework to use them.
</p>

<h3 id="downloads">Downloads</h3>

<p>
In Linux land you often use <samp>wget</samp> to download single files from the web,
and an ftp client like <samp>lftp</samp> to download files from an ftp server.
In BSD the included <samp>ftp</samp> program handles both.
Torrents can be downloaded with a number of programs,
such as the command line frontend for transmission:
<samp>transmission-cli torrent-file</samp> or <samp>transmission-cli magnet-url</samp>
(another good CLI torrent application is <samp>rtorrent</samp>).
</p>

<p>
<samp>wget</samp> can also be used to do quite complex downloads.
For instance this command continues a previous ripping of a website,
pretending to be Firefox and only downloading files at random intervals:
<samp>wget --continue --random-wait -r -p -e robots=off -U mozilla www.somesite.com</samp>
</p>

<h3 id="chatting">Chatting</h3>

<p>
The classic way to chat over the internet on a console is by IRC.
Many UNIX developers and powerusers still use this technology,
and it's a great way to get free support.
Two popular IRC clients for the console are <samp>irssi</samp> and <samp>weechat</samp>.
</p>

<p>
There are other clients that can handle other chat protocols.
For instance,
<samp>pidgin</samp> is a popular chat client on the desktop that can handle most chat protocols,
such as Google talk, Facebook Messenger, MSN and what not.
There are also Skype and Telegram plugins for it (text only though).
Pidgin has a command line front end called <samp>finch</samp>,
which uses the same libraries and configuration files,
so any account and contact information made on one will also appear in the other.
If you are in to Slack,
there is a terminal client for that chat service,
called <samp>slack-term</samp>.
And there are other clients besides,
too numerous to mention,
choose whatever trash can that fits your social garbage.
</p>

<h3 id="email">Email</h3>

<p>
The standard program for reading and sending email in UNIX is <samp>mail</samp>.
Like <samp>vi</samp> you need to learn a handful of keybindings to use it,
but these are quite mnemonic.
The mail commands can either be written in long format,
such as <samp>print</samp> or short as in <samp>p</samp>.
When you open <samp>mail</samp> it presents a numbered list of all your email.
You can <samp>print</samp> message 2 like this: <samp>print 2</samp>.
When you are done reading it you can:
<samp>delete</samp> it,
<samp>reply</samp> to it,
<samp>save /path/to/file</samp> it or move to the <samp>next</samp> email.
You can also list the email <samp>headers</samp> again,
that is,
print a list of your email inbox.
When you are done you can <samp>quit</samp>.
</p>

<p>
To type an email run <samp>mail -s subject person@email.adress</samp>,
you can then write your email and end it by hitting <kbd>Ctrl</kbd> + <kbd>d</kbd>
(which in UNIX means "end of file"),
or <samp>mail -s subject person@email.adress < myemail</samp>.
You can do other thing as well such as attach files to email messages,
mark an email as junk,
delete all junk mail,
and so on...
Read the manpage for the specifics.
Of course this all assumes that you have configured your machine to function as an email server.
The method of doing so is depressingly complicated,
and highly dependent on what system you are using,
and what choices you make.
It is well beyond the scope of this article.
</p>

<p>
You can however use <samp>offlineimap</samp> to sync your external email,
such as Gmail,
to a local directory,
and then use <samp>mail</samp> or <samp>mutt</samp>
(or the newer fork <samp>neomutt</samp>)
to read them.
You can also use <samp>msmtp</samp> to send email via an external provider such as Gmail.
The exact configuration here depends on what kind of external email you are using,
and other details,
but its relatively straight forward.
You can find good examples out there on the net,
and the Arch Linux wiki,
as always,
have some really good tips on the subject.
The aforementioned <samp>mutt</samp> email client is also capable of using an external email provider all on its own.
The following example shows how you can configure <samp>mutt</samp> to use Gmail 
(<i>Ps</i>:
I do not recommend using Google services,
this is just an example).
Put the following in <samp>~/.muttrc</samp>:
</p>

<p>
<pre>
<samp>
# IMAP Settings
set imap_server = 'myuser'
set realname = 'My Real Name'
set from = 'myser@gmail.com'
set imap_pass = 'mypassword'

# Remote GMail Folders
set folder = 'imaps://imap.gmail.com:993'
set spoolfile = '+INBOX'
set postponed = '+[Gmail]/Utkast'
set trash = '+[Gmail]/Papirkurv'
set record = '+[Gmail]/Sendt e-post'

# Local folders for cached headers and certificates
set header_cache = ~/.mutt/cache/headers
set message_cachedir = ~/.mutt/cache/bodies
set certificate_file = ~/.mutt/certificates

# SMTP Settings
set smtp_url = 'smtp://myuser@smtp.gmail.com:587/'
set smtp_pass = 'mypassword'

# Securing
set move = no
set imap_keepalive = 900

# Handle HTML emails with w3m
auto_view text/html
</samp>
</pre>
</p>

<p>
And we need to create a couple of directories and add a mailcap line for this to work:
</p>

<p>
<pre>
<samp>
$ <i>mkdir -p ~/.mutt/cache/bodies</i>
$ <i>echo 'text/html; w3m -I %{charset} -T text/html; copiousoutput;' >> ~/.mailcap</i>
</samp>
</pre>
</p>

<p>
You can now read your GMail account from the console,
we have even configured <samp>mutt</samp> to use the <samp>w3m</samp> console web browser for reading HTML emails.
</p>

<h3 id="news">News</h3>

<p>
There are a few rss/atom news client's available for the console,
such as <samp>newsbeuter</samp> (or <samp>newsboat</samp>) and <samp>rssowl</samp>.
Some UNIX systems also have the ancient <samp>news</samp> command available,
this command reads any new text files added to <samp>/news</samp> or a similar place.
If your system doesn't have a <samp>news</samp> command, you can easily create one.
You can then either manually download news items and save them to the news directory,
or you can write a script that automatically syncs this directory with some online news service and add it to your crontab.
Here is the script:
</p>

<p>
<pre>
<samp>
#!/bin/sh
# news - read latest from /news
# usage: news

for i in $(ls -t /news/* $HOME/.news_time 2>&1); do
	case $i in
		*' No such file') ;;
		*/.news_time) break ;;
		*) set X$(ls -l $i)
		   echo "
$i: ($3) $6 $7 $8
"
		   cat $i
	esac
done
touch $HOME/.news_time
</samp>
</pre>
</p>

<p>
This short script adapted from <i>The UNIX Programming Environment</i> on page 164,
can teach you a great deal about shell scripting and basic UNIX commands.
It has a bug though, you must have at least one file in <samp>/news</samp> for the script to work properly.
Naturally,
this script is only useful in the extremely rare situation where colleagues are working on a common server,
and actually <i>use</i> that server for communication and project management.
This is the only sensible way to work with computers of course,
but nobody outside of Bell Labs seems to be aware of it.
If you like this kind of workflow,
check out the
<a href="#hipster">Hipster Media</a>
section below. 
</p>

<h3 id="socialmedia">Social Media</h3>

<p>
In Linux there are command line clients for Facebook, Google, Readit and Twitter: 
<samp>fbcmd</samp>, <samp>googlecl</samp>, <samp>rtv</samp>, <samp>ttytter</samp>
(and others).
Of course real hackers update their twitter account like this:
<samp>curl -u myuser:mypassword -d status="Twitting from my shell" http://twitter.com/statuses/update.xml</samp>
Similar clients come and go,
and those that do exist are naturally susceptible to breakage whenever the upstream survice changes.
Some service providers are even so radical that regular HTML browsers,
such as <samp>links</samp> or <samp>w3m</samp>,
can use them.
But that is rare.
</p>

<h3 id="hipster">Hipsters Media</h3>

<p>
There are very good reasons why you shouldn't hand over your data to commercial companies that refuse to give you any control or insight into what they do with it.
If the postman snoops in your private mail,
you have valid grounds to call the police.
But calling the police on Google isn't quite so easy...
And besides sifting through the social garbage on Facebook,
Instagram, Imgur and what not, will likely cause brain damage.
Is there a way to create a local social network on the console,
where the users are fully in control?
</p>

<p>
Sure, 
in fact the technical aspect of sharing data and communicating with a group of people,
is remarkably easy.
That's what UNIX was <i>designed</i> to do!
Simply give your friends user accounts on your server with <samp>adduser</samp> and let them access it securely with <samp>ssh</samp>.
No one can snoop on them now!
(well, except big brother root of course...)
</p>

<p>
You can see who is presently online with <samp>who</samp>,
change and check your online profile with <samp>chfn</samp> and <samp>finger</samp>
(finger will also print the users <samp>~/.plan</samp> and <samp>~/.project</samp> files if they exists),
send them emails with <samp>mail</samp>.
Sending emails internally usually doesn't require any special configuration,
just make sure that a mail server,
like <samp>sendmail</samp> or <samp>exim</samp>,
is running in the background.
Share files with <samp>cp</samp> or <samp>mv</samp>,
control who has read and write access to what with <samp>chmod</samp>
(if your collaborating on a project make a group for it and <samp>chmod -R myuser:mygroup /path/to/project</samp>).
</p>

<p>
Run a centralized news service by putting plain text news items in <samp>/news</samp>.
You can even chat interactively with <samp>write</samp> or <samp>talk</samp>.
PS:
Users can enable or disable this service with <samp>mesg</samp>,
and control whether or not they should be notified about incoming email with <samp>biff</samp>.
<samp>talk</samp> may require some configuration,
and there are more advanced clients for this ancient chat protocol,
such as <samp>ytalk</samp> or <samp>xtalk</samp>.
Of course the <i>social</i> challenge of getting your friends to use these programs will be borderline impossible.
Don't expect to get many "likes" on your hipster network,
but then again that wouldn't be the point now would it :)
</p>

<h2 id="media">Multimedia</h2>

<p>
<a href="images/audio.png"><img src="thumbs/audio.png" title="Radio and other hitech hifi stuff"></a>
</p>

<h3 id="volume">Volume</h3>

<p>
In Linux you can adjust the volume with the <samp>alsamixer</samp> command.
On other systems you have to use other commands.
</p>

<h4 id="volume_freebsd">FreeBSD</h4>

<p>
FreeBSD uses the <samp>mixer</samp> command, which adjusts volume by percentage.
You can for instance do this: <samp>mixer vol 75</samp> or <samp>mixer speaker +10</samp>
</p>

<h4 id="volume_openbsd">OpenBSD</h4>

<p>
There is a nice alsamixer like package available in ports called <samp>cmixer</samp>.
Otherwise you can adjust volume and other sound settings with the <samp>mixerctl</samp> command.
For instance <samp>mixerctl outputs.master=255</samp> will set the speakers to maximum output.
This simple script will let you specify volume in percentage (eg. <samp>volume 75</samp>):
</p>

<p>
<pre>
<samp>
#/bin/sh
# volume - set audio volume
# usage: volume percent

output=$(echo "(255 * $1)/100" | bc)
mixerctl outputs.master=$output
</samp>
</pre>
</p>

<h4 id="volume_netbsd">NetBSD</h4>

<p>
NetBSD also has it's own alsamixer like command called <samp>aiomixer</samp>,
and like OpenBSD,
it too has a <samp>mixerctl</samp> command that works much the same way.
The command will not list the mixer settings if you run it without any flags though,
instead you must run <samp>mixerctl -a</samp>.
And to change settings you must use the <samp>-w</samp> flag: <samp>mixerctl -w outputs.master=195</samp>.
Similarly to OpenBSD the NetBSD mixerctl specifies volume from 0 to 255,
you can easily make the above mentioned OpenBSD volume command for NetBSD by tweaking the example a little.
</p>

<h4 id="volume_illumos">Solaris and Illumos</h4>

<p>
You can change audio configuration with the <samp>audioctl</samp> command.
For instance you should be able to set the volume to 50% by doing something like this: <samp>audioctl set-control volume 50</samp>.
Exactly what controls are available may depend on your hardware,
you can check with <samp>audioctl show-control</samp>.
(Read the full man page for further instructions)
</p>

<p>
As a side note:
I had some hardware problems on my test machine.
The first audio device <samp>/dev/sound/audiohd:0</samp> did not work,
but the second one <samp>/dev/sound/audiohd:1</samp> did.
Unfortunately the system choose the wrong card as the default!
Well, no problem, this quick fix solved it:
<samp>ln -sf /dev/dsp1 /dev/dsp</samp>.
You can test if your audio works with <samp>audiotest</samp>
</p>

<h3 id="video">Video</h3>

<p>
If you have configured your
<a href="#framebuffer">framebuffer</a>
correctly in Linux,
you can watch videos in the console with <samp>vlc -I ncurses movie.mpeg</samp>.
You might get a garbled screen when the movie is finished playing,
if so type <samp>reset</samp>.
Another fine alternative here is <samp>mplayer</samp>.
Like <samp>vi</samp> you need to learn a few key-bindings before you can truly appreciate this program.
You can play a movie in the framebuffer like so:
<samp>mplayer -vo fbdev2 -vf scale=1366:768 movie.mpeg</samp>.
The resolution must match exactly the resolution of your framebuffer,
this is usually the same as your maximum Xorg resolution.
(you can check this in X with the command <samp>xrandr</samp>)
</p>

<p>
Some key-bindings to help you get started with <samp>mplayer</samp>:
You can pause and unpause the movie with space,
change volume with <kbd>0</kbd> and <kbd>9</kbd>,
jump forward or backward with <kbd>arrow</kbd> keys or <kbd>pageup</kbd> or <kbd>pagedown</kbd>,
and quit with <kbd>q</kbd>.
</p>

<p>
In theory you should be able to play movies on the console with <samp>mpv</samp>,
but you probably need to recompile mpv with <samp>--enable-sdl</samp> and <samp>--enable-sdl2</samp>,
and you may need to recompile sdl2 with <samp>--enable-video-directfb</samp>.
I have not tested this myself.
</p>

<p>
<a href="https://pspodcasting.net/images/dan/blog/2018/video.png"><img src="thumbs/video.png" title="Kudos to anyone who can guess what movie this is!"></a>
</p>

<h3 id="youtube">Youtube</h3>

<p>
There are a couple of ways you can watch youtube movies in the Linux console.
One is to navigate to the video you want with a console browser,
such as <samp>lynx</samp>.
When you have found the right url,
hit <kbd>G</kbd>,
now left click and mark the url
(supposing you have configured <samp>gpm</samp>).
Hit <kbd>Ctrl</kbd> + <kbd>c</kbd> to quit <samp>lynx</samp>.
Now either type <samp>youtube-dl</samp> and middle click to paste the url,
to download the video,
or type <samp>vlc</samp> (or <samp>mplayer</samp>) and paste the url to watch the video directly
(you can copy paste the url with <samp>tmux</samp> also if you prefer).
</p>

<p>
Another program you could use is <samp>youtube-viewer</samp>.
You can either run <samp>youtube-viewer -d</samp> to download the movies instead of watching them,
and then later play them with <samp>vlc</samp> or <samp>mplayer</samp>.
Or you can edit <samp>~/.config/youtube-viewer/youtube-viewer.conf</samp> and set the appropriate <samp>mplayer</samp> or <samp>vlc</samp> args to play the movies directly in the framebuffer.
</p>

<h3 id="music">Music</h3>

<p>
Besides playing music with <samp>vlc</samp> or <samp>mplayer</samp>,
there is a ton of music players available for the console!
A very simple one witch I really like is <samp>mocp</samp>
("music on console player").
Adjust volume with <kbd>,</kbd> (comma) and <kbd>.</kbd> (dot),
display available key-bindings with <kbd>?</kbd>.
You can open a directory with <kbd>i</kbd>,
and start playing music files here by selecting it and hitting <kbd>enter</kbd>.
Or you can add the song to your playlist with <kbd>a</kbd>,
clear the playlist with <kbd>C</kbd>,
when the playlist is populated correctly switch to it by <kbd>tab</kbd>
and hit <kbd>enter</kbd>.
Shuffle with <kbd>S</kbd> or repeat with <kbd>R</kbd> if you want to.
Other popular alternatives are <samp>cmus</samp>,
<samp>mp3blaster</samp> and others.
There are also several more basic audio players available.
The <samp>sox</samp> package discussed below for instance,
includes the <samp>play</samp> command,
which is quite capable of playing any kind of audio file.
</p>

<h3 id="radio">Internet Radio</h3>

<p>
You can play internet streams with <samp>mplayer</samp> and other media players,
but this requires you to find the correct stream URL's.
This is more tricky then you might think since streaming websites will usually not display these URL's directly.
Often you need to snoop around in the website HTML code in order to find them.
Here is a somewhat Apple-centric example
(yes I know - <i>do</i> feel free to change it!) 
list to get you started:
(you can append it to your <samp>~/.profile</samp> or <samp>~/.bashrc</samp>)
</p>

<p>
<pre>
<samp>
alias news="mplayer -playlist http://minnesota.publicradio.org/tools/play/streams/news.pls" # MPR News
alias current="mplayer -playlist http://minnesota.publicradio.org/tools/play/streams/the_current.pls" # The Current 
alias classical="mplayer -playlist http://minnesota.publicradio.org/tools/play/streams/classical.pls" # Classical MPR 
alias localcurrent="mplayer -playlist http://minnesota.publicradio.org/tools/play/streams/local.pls" # Local Current 
alias heartland="mplayer -playlist http://minnesota.publicradio.org/tools/play/streams/radio_heartland.pls" # MPR Radio Heartland 
alias wonderground="mplayer http://wondergroundstream2.publicradio.org/wonderground" # MPR Wonderground Windows Media 
alias choral="mplayer -playlist http://choralstream1.publicradio.org/choral.m3u" # Classical MPR Choral
alias wefunk="mplayer -playlist http://www.wefunkradio.com/play/shoutcast.pls" # WEFUNK Radio MP3 64K
alias sleepbot="mplayer -playlist http://sleepbot.com/ambience/cgi/listen.cgi/listen.pls" # Sleepbot Environmental Broadcast 56K MP3
alias groovesalad="mplayer -playlist http://somafm.com/groovesalad130.pls" # Soma FM Groove Salad iTunes AAC 128K
alias dronezone="mplayer -playlist http://somafm.com/dronezone130.pls" # Soma FM Drone Zone iTunes AAC 128K
alias lush="mplayer -playlist http://somafm.com/lush130.pls" # Soma FM Lush iTunes AAC 128K
alias sonicuniverse="mplayer -playlist http://somafm.com/sonicuniverse.pls" # Soma FM Sonic Universe iTunes AAC 128K
</samp>
</pre>
</p>

<p>
You can also set up your own radio stream with <samp>mpd</samp>,
and play it locally with <samp>mpc</samp>,
<samp>ncmpcpp</samp> or another MPD client.
</p>

<p>
Here is an example setup,
place it in <samp>/etc/mpd.conf</samp> for a system wide service,
or <samp>~/.config/mpd/mpd.conf</samp> if you plan to run it as a user process:
</p>

<p>
<pre>
<samp>
db_file             "~/.config/mpd/database"
log_file            "syslog"
music_directory     "~/music"
auto_update         "yes"
playlist_directory  "~/.config/mpd/playlists"
pid_file            "~/.config/mpd/pid"
state_file          "~/.config/mpd/state"
sticker_file        "~/.config/mpd/sticker.sql"
</samp>
</pre>
</p>

<p>
Run <samp>mkdir ~/.config/mpd/playlists</samp> if this directory does not exist.
Your now all set,
just run <samp>mpd</samp>,
and then you can launch an MPD client,
such as <samp>ncmpcpp</samp> to play your music.
</p>

<h3 id="spotify">Spotify, LastFM and Podcasts</h3>

<p>
There are command line clients for these online services:
<samp>despotify</samp>
was a good Spotify client,
but seems to have been abandoned,
<samp>ncspot</samp> is another alternative.
For LastFM and podcasts,
you can use <samp>shell-fm</samp> and <samp>bash-podder</samp>
(of course for podcasts you could just manually download them and use your favorite music player).
These commands are rare to see outside Linux repositories,
but you might be able to compile them yourself on your favorite OS all the same.
</p>

<p>
You can also install <samp>Mopidy</samp> (Linux only),
which can be configured to play music from Spotify and other streaming services as an MPD service,
you can then listen to Spotify with one of the many MPD clients.
For example,
after <samp>mopidy</samp> and <samp>mopidy-spotify</samp> is installed,
you can add this to <samp>/etc/mopidy/mopidy.conf</samp>
(or <samp>~/.config/mopidy/mopidy.conf</samp> if run as a user process):
</p>

<p>
<pre>
<samp>
[audio]
output = tee name=t ! queue ! autoaudiosink t. ! queue ! udpsink
port=5555

[spotify]
enabled = true
username = [username] # Must have Spotify Premium
password = [password]
bitrate = 320
</samp>
</pre>
</p>

<p>
You can then configure the MPD client <samp>ncmpcpp</samp> to use this,
by adding this to <samp>~/.ncmpcpp/config</samp>:
</p>

<p>
<pre>
<samp>
visualizer_fifo_path = "/tmp/mpd.fifo"
visualizer_output_name = "my_fifo"
visualizer_sync_interval = "30"
visualizer_in_stereo = "yes"
visualizer_type = "spectrum"
visualizer_look = "+|"
</samp>
</pre>
</p>

<p>
You can now launch the spotify client like so:
<samp>nohup mopidy & ; mkfifo /tmp/mpd.fifo ; while :
do yes $'\n' | nc -lu 127.0.0.1 5555 > /tmp/mpd.fifo
done & ; ncmpcpp</samp>
If you don't care about visualization,
and <samp>mopidy</samp> is already running as a service,
it would suffice to just run <samp>ncmpcpp</samp>.
</p>

<h3 id="making_music">Making Music and Video</h3>

<p>
You will not find a massive studio software suit,
complete with pointy-clicky interface,
for the console,
but you can do a whole lot of productive audio/video work nonetheless.
</p>

<p>
To begin with,
you can record audio with <samp>rec</samp>,
which is included in the <samp>sox</samp> package,
or you can use a more native approach:
</p>

<p>
<ul>
  <lh>Linux</lh>
  <li><samp>arecord -f cd -d 600 -t raw | lame -x -r - out.mp3</samp>, record for 10 minutes and convert to mp3</li>
  <li><samp>arecord -f cd -t raw | oggenc - -r -o out.ogg</samp>, record and convert to ogg (hit Ctrl-D or -C when done)</li>
</ul>
<ul>
  <lh>UNIX (FreeBSD/Solaris)</lh>
  <li><samp>cat /dev/dsp > bla</samp> record from device dsp, save raw output to <i>bla</i></li>
  <li><samp>cat bla > /dev/dsp</samp> play (raw) audio file over the speakers</li>
  <li><samp>cat /dev/dsp > /dev/dsp</samp> play from record device to speakers</li>
</ul>
(PS: You may want to use </i>/dev/dspW</i> in FreeBSD)
<ul>
  <lh>OpenBSD</lh>
  <li><samp>aucat -i file1.wav -i file2.wav -o file3.wav</samp> mix and play two audio files while recording a third (see also <i>mixerctl(1)</i>)</li>
</ul>
</p>

<p>
For recording video see the <a href="#screencapture">screen capturing</a> section.
</p>

<p>
The Jack Audio Connection Kit sound server is available on practically all modern UNIX'es,
and can be used from the command line to organize and mangle your audio equipment.
<samp>ffmpeg</samp> and <samp>sox</samp> can be used to edit audio and video in various ways.
Here are some examples:
</p>

<p>
<ul>
  <li><samp>ffmpeg -i file.mpg -ss 120 -t 300 -c copy output.mpg</samp>, copy a 5 minute cut starting 2 minutes into the file, you can do the same for audio files</li>
  <li><samp>ffmpeg -i video.mpg -hide_banner</samp>, display information about video</li>
  <li><samp>ffmpeg -i video.mpg image%d.jpg</samp>, convert video to jpg images</li>
  <li><samp>ffmpeg -f image2 -i image%d.jpg output.mpg</samp>, convert a set of image*.jpg images into a video</li>
  <li><samp>ffmpeg -i video.mpg -vn -ar 44100 -ac 2 -ab 192 -f mp3 output.mp3</samp>, convert video to mp3 audio</li>
  <li><samp>ffmpeg -i video.mpg -i audio.mp3 output.mpg</samp>, merge video and audio</li>
  <li><samp>ffmpeg -loop 1 -i audio.mp3 -i picture.jpg -c:v libx264 -c:a aac -strict experimental -b:a 192k -shortest output.mp4</samp>, merge audio and image</li>
  <li><samp>ffmpeg -i video.flv output.mpg</samp>, convert flv to mpg</li>
  <li><samp>ffmpeg -i video.mpg output.gif.mpg</samp>, convert mpg to gif</li>
  <li><samp>ffmpeg -i video.mpg -ab 26k -f flv output.flv</samp>, convert mpg to flv</li>
  <li><samp>ffmpeg -i video.avi -target pal-dvd -ps 2000000000 -aspect 16:9 output.mpg</samp>, convert avi to mpg</li>
  <li><samp>ffmpeg -i video.mpg -target vcd output.mpg</samp>, convert video to DVD format</li>
  <li><samp>ffmpeg -i video.mpg -i subtitle.sub -map 0 -map 1 -c copy -c:v libx264 -crf 23 -preset veryfast output.mkv</samp>, merge video and subtitle</li>
  <li><samp>for file in *; do sox $file -r 8000 out/$file ; done</samp>, resample audio files and put them in the out directory</li>
</ul>
</p>

<p>
If you plan to do a lot of audio/video work in the command line,
you may find it useful to create some aliases for these commands.
(or whatever variations of them you may need)
</p>

<p>
Ripping audio CD's can be done with <samp>cdparanoia</samp>
(OpenBSD has it's own excellent cd tool, <samp>cdio</samp>),
and <samp>vobcopy</samp> is a good DVD ripper.
(see the
<a href="#dvd">cd's, dvd's and bluerays</a>
section for more information)
If you want to rip a radio stream,
<samp>streamripper</samp> is a good candidate.
Finally the <samp>mplayer</samp> package also includes <samp>mencoder</samp>,
which can rip any media that <samp>mplayer</samp> can play,
you can also use it to edit the video/audio stream in various ways.
</p>

<h2 id="graphics">Graphics</h2>

<p>
<a href="images/graphics.png"><img src="thumbs/graphics.png" title="Now in Technicolor and Supermarionation!"></a>
</p>

<h3 id="pictures">Pictures</h3>

<p>
A few image viewers can be used in combination with the
<a href="#framebuffer">framebuffer</a> on Linux.
My favorite is <samp>fbi</samp>.
You can open a picture with <samp>fbi picture.jpeg</samp>,
or a directory of pictures with <samp>fbi pictures/*</samp>,
and navigate back and forth with <kbd>n</kbd> and <kbd>p</kbd>,
and zoom in or out with <kbd>-</kbd> and <kbd>+</kbd>.
</p>

<p>
Some people recommend <samp>zgv</samp> to view images in the console,
but I have never managed to get this program to work on my machine...
</p>

<h3>Making Pictures</h3>

<p>
There is no "PhotoShop" for the console,
but you can easily "make" pictures with a camera,
and work with these on a console.
Just use a memory card reader to retrieve the pictures,
and you can view them with <samp>fbi</samp>,
and organize them into whatever directories and naming scheme you like.
</p>

<p>
The process of mounting a memory card is similar to mounting a USB memory stick,
although the device names are different.
Stick your memory card in the reader and run <samp>dmesg | tail</samp>
to find out what the device is called.
On my Linux box this command gave me this output:
</p>

<p>
<samp>
<pre>
[   20.443125] mmc0: new ultra high speed SDR50 SDHC card at address e624
...
[   20.493617]  mmcblk0: p1
</pre>
</samp>
</p>

<p>
Don't worry too much about all the details here,
the important thing to notice is that a new SD card was detected,
and that a new device called <samp>mmcblk0</samp>
(with partition <samp>p1</samp>)
was created.
We can now mount the device and copy over the images:
</p>

<p>
<pre>
<samp>
$ <i>sudo mount /dev/mmcblk0p1 /mnt/hd</i>
$ <i>cp /mnt/hd/DCIM/100NIKON/* Pictures/vacation_2018</i>
</samp>
</pre>
</p>

<p>
As you can see my camera organized its pictures in DCIM/100NIKON,
but yours may do things differently.
Once mounted just use <samp>ls</samp> and find out.
(PS: If you are having trouble you can always buy a cheap usb memory card reader on ebay,
you can then mount your memory card like an ordinary usb memory stick)
</p>

<p>
For scanners see the
<a href="#printer">printers and scanners</a>
section.
</p>

<p>
You can also edit photos from the console,
using the <samp>ImageMagick</samp> collection of tools
(a good alternative here is <samp>GraphicsMagick</samp>).
Here are some of its utilities:
</p>

<p>
<ul>
  <li>identify - print information about an image</li>
  <li>convert - convert image format, or resize, blur, crop, flip, join etc...</li>
  <li>mogrify - much the same as convert, but alter the image directly don't make a copy</li>
  <li>montage - create a composite image out of several others</li>
  <li>composite - overlap one image over another</li>
</ul>
</p>

<p>
These tools give you quite a lot of scripting power to manage your photos.
It is well worth learning,
even if you are only interested in using a desktop environment.
You can find many good tutorials for this software suit online
</p>

<h3 id="pdf">PDF and Postscript</h3>

<p>
The <samp>fbi</samp>
(or <samp>fbida</samp>)
package mentioned above usually include <samp>fbipdf</samp>.
(sometimes called <samp>fbpdf</samp>)
This program can be used to view PDF's on the framebuffer like so:
<samp>fbipdf document.pdf</samp>.
Also some old versions of <samp>fbi</samp> do not include <samp>fbipdf</samp>,
in such cases you can usually use the inferior <samp>fbgs</samp> program.
</p>

<p>
If you don't have a framebuffer available,
you can convert a PDF to HTML or plain text with <samp>pdftohtml</samp> and <samp>pdftotext</samp>,
both of witch are a part of the <samp>poppler</samp> (or <samp>poppler-utils</samp>) package.
You can also use <samp>pdfimages</samp> from the poppler tools to extract images in a PDF.
For instance you could to this:
</p>
<p>
<pre>
<samp>
$ <i>pdftohtml -s -i document.pdf</i>
$ <i>lynx document-html.html</i>
$ <i>pdftotext -layout document.pdf</i>
$ <i>less document.txt</i>
</samp>
</pre>
</p>

<p>
Exactly how well this works depends very much upon the PDF in question.
If you are lucky,
the conversion is merely bad,
if you are unlucky,
it's unreadable.
Some PDF's are simply a collection of JPEG's of text,
the poppler tools cannot convert such documents.
You can try with <samp>ocrmypdf</samp> or other OCR solutions
(see <a href="#ocr">discussion</a> below).
</p>

<p>
The poppler utils can do some basic editing as well,
such as extracting pages from a PDF or merging pages into a single PDF,
checking the metainfo and more.
An alternative PDF editing tool is <samp>pdftk</samp>.
Of course non of these tools are interactive,
so they are mostly useful for basic batch editing and scripting.
</p>

<h3 id="ocr">OCR</h3>

<p>
Sadly OCR support, that is scanning a document and converting the image to plain text,
is not well supported in the open source world.
The only widely available tool is tesseract, here is a short demonstration of its usage:
</p>

<p>
<pre>
<samp>
$ <i>scanimage --mode grey --resolution 300 > scan.pnm</i>
$ <i>unpaper -b 0.5 -w 0.8 -l single scan.pnm scan1.pnm</i>
$ <i>convert scan1.pnm scan.tif</i>
$ <i>tesseract scan.tif scan.txt</i>
</samp>
</pre>
</p>

<p>
This example uses commands from the sane-backends, unpaper and ImageMagick packages.
The results of this OCR depends much upon the quality of the scan,
the higher the resolution the better,
and it also requires you to have installed the correct language packages for tesseract
(eg. tesseract-ocr-fra or similar if the document is French).
</p>

<h3 id="ascii">Asciiart</h3>

<p>
For the geeky console user,
asciiart can provide much fun.
Note however that non-Linux consoles that don't support video playback,
either don't have asciiart support at all,
or they don't have good enough font support to make it practical.
If you install the <samp>libcaca</samp>
(sometimes called <samp>caca-utils</samp>)
package,
you can view images with <samp>cacaview</samp> or convert them to text files with <samp>img2txt</samp>.
The related <samp>libaa</samp> is used for black and white asciiart,
it includes the fun <samp>bb</samp> demo.
You can even play videos in asciiart with something like this:
<samp>mplayer -vo caca myvideo.mkv</samp>,
or
<samp>vlc -V aa https://youtube.com/some_url...</samp>.
Speaking of video <samp>hasciicam</samp> will let you play video output from your webcam in ASCII!
PS:
The quality of your asciiart images depends on what fonts you use.
The smaller the font,
the greater the resolution
(see <a href="#configuration">console configuration section</a> on how to do this).
</p>

<p>
<a href="https://pspodcasting.net/images/dan/blog/2018/ascii.png"><img src="thumbs/ascii.png" title="With a small enough font you can almost kinda see whats going on..."></a>
</p>

<p>
Although your artistic painting skills may be limited on the console,
you can freely draw asciiart.
There are a few programs designed specifically for this purpose,
such as <samp>cadubi</samp>,
but <i>real</i> pros do their ASCII painting in <samp>vi</samp>
(of course <samp>ed</samp> users scoff at such newbs...)!
</p>

<h2 id="peripherals">Peripherals</h2>

<p>
<a href="images/printer.png"><img src="thumbs/printer.png" title="Office hardware we all take for granted, except Stallman"></a>
</p>

<h3 id="usb">USB Memory Sticks</h3>

<p>
See the <a href="#disk">disk management</a> section for more details about formatting USB memory sticks,
in this section we will only talk about mounting such devices.
The device name used in the examples are typical for these operating systems,
but yours may be different
(it may be <samp>sdb1</samp> not <samp>sdd1</samp> for example).
After attaching your memory stick you can run <samp>dmesg | tail</samp> to check what the system called the device,
or to see if there were any errors.
Finally,
depending on your security setup,
you may need to use <samp>sudo</samp> to run some of these commands.
</p>

<h4>Linux</h4>

<p>
<pre>
<samp>
$ <i>mkdir -p /mnt/usb</i>                 # make a directory to mount the usb device in
$ <i>mount /dev/sdd1 /mnt/usb</i>
$ <i>cp -r /mnt/usb $HOME/Downloads</i>    # use the usb device like a regular directory
$ <i>umount /mnt/usb</i>                   # safely unmount the device
</samp>
</pre>
</p>

<h4>FreeBSD/DragonFly BSD</h4>

<p>
<pre>
<samp>
$ <i>mount -t msdosfs /dev/da0s1 /mnt/usb</i>
$ <i>umount /mnt/usb</i>
</samp>
</pre>
</p>

<h4>OpenBSD/NetBSD</h4>

<p>
<pre>
<samp>
$ <i>disklabel sd0</i>                     # check the partition name
$ <i>mount /dev/sd0i /mnt/usb</i>
$ <i>umount /mnt/usb</i>
</samp>
</pre>
</p>

<h4>Solaris/Illumos</h4>

<p>
<pre>
<samp>
$ <i>rmformat</i>                         # check the partition name
$ <i>mount -F pcfs /dev/dsk/c0t0d0p0:c /mnt/usb</i>
$ <i>umount /mnt/usb  && eject /dev/dsk/c0t0d0p0</i>
</samp>
</pre>
</p>

<h3 id="dvd">CD's, DVD's and BlueRays</h3>

<p>
Ripping CD's and DVD's can be done with <samp>cdparanoia</samp> and <samp>vobcopy</samp>.
Writing CD's and DVD's can be done with <samp>cdrecord</samp>
(or <samp>dvd+rw-format</samp>)
and <samp>growisofs</samp>,
and making iso files can be done with <samp>mkisofs</samp>.
OpenBSD has it's own program for ripping and writing CD's,
<samp>cdio</samp>.
As for playing music and video from such media see the
<a href="#media">Multimedia</a>
section.
</p>

<p>
The following examples show how to create and mount ISO files,
and how to burn such data to a CD/DVD:
(you may need <samp>sudo</samp> for some of these commands)
</p>

<h4>Linux</h4>

<p>
<pre>
<samp>
$ <i>mkisofs -o mydisk.iso /my/path</i>	# make an iso data file
$ <i>mkdir -p /mnt/cd</i>              	# make a directory to mount the iso in
$ <i>mount /dev/cdrom0 /mnt/cd</i>     	# mount cd
$ <i>mount /dev/dvd0 /mnt/cd</i>       	# mount dvd
$ <i>mount -o loop mydisk.iso /mnt/cd</i>	# mount iso
$ <i>umount /mnt/cd</i>                    	# unmount cd/dvd/iso
$ <i>cp -r /mnt/cd $HOME/Downloads</i>     	# use the iso like a regular directory (read only)
$ <i>cdrecord -scanbus</i>			# check the device name of the cd/dvd burner
$ <i>cdrecord mydisk.iso</i>
$ <i>cdrecord -dao -useinfo *.wav</i>		# write an audio cd/dvd
$ <i>mkisofs -R -J -udf -iso-level 3 -o mydvd.iso /my/path</i>    # make a dvd iso data file
$ <i>growisofs -dvd-compat -Z /dev/cd0=mydvd.iso</i>              # write a data dvd
</samp>
</pre>
</p>

<p>
Much the same can be done for other UNIX systems,
but the device names may be a little different.
And they might require you to create a virtual device for the iso file,
before you can mount it:
</p>

<h4>FreeBSD/DragonFly BSD</h4>

<p>
<pre>
<samp>
$ <i>mdconfig -a -t vnode -f mydisk.iso -u 0</i>
$ <i>mount -t cd9600 /dev/md0 /mnt/cd</i>
$ <i>mount /dev/cd0 /mnt/cd</i>
</samp>
</pre>
</p>

<h4>OpenBSD/NetBSD</h4>

<p>
<pre>
<samp>
$ <i>cdio play</i>                         # play audio cd (cdio is OpenBSD only)
$ <i>cdio tao mydisk.iso</i>               # write data cd
$ <i>cdio cdrip</i>                        # rip audio cd
$ <i>cdio tao -a *.wav</i>                 # write audio cd
$ <i>vnconfig vnd0 mydisk.iso</i>
$ <i>mount /dev/vnd9c /mnt/cd</i>
$ <i>mount /dev/cd0c /mnt/cd</i>
$ <i>growisofs -dvd-compat -Z /dev/rcd0c=mydvd.iso</i>            # write a data dvd
</samp>
</pre>
</p>

<h4>Solaris/Illumos</h4>

<p>
CD's should be auto mounted in <samp>/media</samp>,
you can double check with <samp>rmformat</samp>.
</p>

<p>
<pre>
<samp>
$ <i>mount -F hsfs mydisk.iso /mnt/cd</i>
</samp>
</pre>
</p>

<h3 id="printer">Printers and Scanners</h3>

<p>
Practically all modern UNIX'es use CUPS and SANE to manage printers and scanners.
Installing a printer from the console is tricky if you don't know what you are doing.
So for this one task its probably better to use a graphical desktop and configure CUPS using a modern web browser,
such as Firefox.
Just go to <samp>localhost:631</samp> and enter your root password.
Many UNIX systems have large collections of printer drivers available by default,
but if you cant find your model,
head over to
<a href="https://openprinting.org/drivers">openprinting.org</a>
and search for a driver.
If you cannot find your exact model try to find a driver for a similar device.
For example,
I could not find a driver for my HL-2035 Brother printer,
but I did find one for the HL-2030 that worked just fine.
Once the printer is set up,
installing it on other UNIX machines using the console is easy.
Just copy the printer configuration file <samp>/etc/cups/printers.conf</samp>,
and optionally other configuration files that might be relevant,
such as the drivers in <samp>/etc/cups/ppd</samp>.
</p>

<p>
If you have configured your printer as the server default,
you can use the following commands to print documents:
</p>

<p>
<pre>
<samp>
$ <i>lpr document.pdf document.ps document.txt</i>
$ <i>enscript document.txt</i>		# print text as postscript (looks nicer)
$ <i>lpq</i>				# list printing jobs
$ <i>lprm</i>				# remove a print job0
</samp>
</pre>
</p>

<p>
PS: Some UNIX systems may already have a native <samp>lpr</samp> and related suite of applications.
In FreeBSD for example,
the native print command is <samp>/usr/bin/lpr</samp>,
while the CUPS print command is in <samp>/usr/local/bin/lpr</samp>.
In OpenBSD the CUPS command is called <samp>lpr-cups</samp>,
to distinguish it from the native <samp>lpr</samp> command.
Run <samp>which -a lpr</samp> to check if your system has more then one print command.
</p>

<p>
Scanners are also easy to use from the console,
using the <samp>sane</samp> collection of tools,
for instance:
<samp>scanimage >image.pnm</samp>
</p>

<p>
Most scanners should be plug-and-play,
check the sane documentation or google if you are having problems.
</p>

<h2 id="game">Gaming</h2>

<p>
Don't expect the triple A games on your Steam account to work in the console!
The console is not a popular platform for gaming for obvious reasons,
but there are a few simple candidates to choose from.
Some of my favorites are <samp>myman</samp>,
<samp>sudoku</samp> and
<samp>vitetris</samp>
(or you can try <samp>basted</samp> if you *like* getting frustrated).
There is also <samp>cpat</samp> for all kinds of solitaire fun,
and the "racing" games <samp>moon-buggy</samp> and <samp>ztrack</samp>.
<samp>ASCIIpOrtal</samp> is an amazingly cool game,
even if it's quite obscure and unmaintained.
You can find a lot more suggestions,
and plenty of online tty games
<a href="https://github.com/ligurio/awesome-ttygames">here</a>.
The classic <samp>bsdgames</samp> and <samp>gnuchess</samp> might also provide you with some fun,
if you happen to be a meganerd...
</p>

<h3 id="strategy_games">Strategy Games</h3>

<p>
<a href="images/empire.png"><img src="thumbs/empire.png" title="Yes - there are strategy games for the terminal"></a>
</p>

<p>
There are precious few strategy games for the console,
but here are a couple of good ol' classics:
<samp>starlanes</samp> is an economic conquest game,
and is great fun to play hotseat with a couple of friends
(you would have to have some pretty nerdy friends though...).
<samp>vms-empire</samp> (or just <samp>empire</samp>) is a lot more elaborate,
it's sort of basic Civilization for the terminal.
Its "vi-like" interface takes some getting used to though,
and you will have to skim through the manual a few times.
Here are some quick starting points:
After typing <kbd>a</kbd> to enter "auto-mode" at the beginning of the game,
and <kbd>a</kbd> again to produce armies in your city,
you want to command your new units to auto explore with <kbd>y</kbd>.
To change a units orders or change a cities production,
type <kbd>j</kbd> to enter "edit-mode".
From here you can cancel a units orders with <kbd>k</kbd>,
and change what a city builds with <kbd>b</kbd>,
hit <kbd>o</kbd> to go out of "edit-mode".
When you want to quit the game,
hit <kbd>o</kbd> to go out of "auto-mode",
and into "command-mode".
This will take effect once you have completed your round,
so move any remaining units until the game finally asks you for a command.
At this point you can type <kbd>s</kbd> to save,
and <kbd>q</kbd> to quit.
A final tip,
you want to start this game with <samp>vms-empire -d0</samp>!
Have Fun :)
</p>


<h3 id="framebuffer_games">Framebuffer Games</h3>

<p>
If your running Linux a few SDL games can actually run in the
<a href="#framebuffer">framebuffer</a>.
One example is <samp>dosbox</samp>,
this DOS emulator can run pretty much any old game from the early 90's.
If you're a retro gamer like me,
<samp>dosbox</samp> opens up a world of gaming for the console!
You need to tweak the <samp>~/.dosbox/dosbox-*.conf</samp> setting a bit for programs to work well.
These are the settings I use:
</p>
<p>
<pre>
<samp>
fullscreen=true
fulldouble=false
fullresolution=1680x1050
windowresolution=1680x1050
output=overlay
usescancodes=false
keyboardlayout=us
aspect=false
scaler=none
</samp>
</pre>
</p>
<p>
Note that the resolutions must match your framebuffer resolution,
witch is usually the maximum resolution in Xorg.
And output must be "overlay" with no fancy scaler,
otherwise fullscreen resolution will not work.
Also be sure to disable userscancodes and set a keyboard layout manually,
since userscancodes do not work in the framebuffer!
</p>

<p>
<a href="https://pspodcasting.net/images/dan/blog/2018/dosbox.png"><img src="thumbs/dosbox.png" title="Oh yeah! Dosbox can run on the console :D"></a>
</p>

<p>
<samp>scummvm</samp> might also works in the framebuffer
(it did not in debian),
but getting the resolution right is not easy.
You can try something like <samp>scummvm -g hq3x</samp>,
and hopefully this will work for you...
</p>

<h3 id="roguelikes">Roguelikes</h3>

<p>
<a href="images/cataclysm.png"><img src="thumbs/cataclysm.png" title="Check out roguelikes for some *SERIOUS* terminal gaming!"></a>
</p>


<p>
The big gaming genre on the UNIX console is of course roguelikes.
Roguelikes are 2D dungeon exploration RPG games.
The name comes from the game <samp>rogue</samp>,
which was the first game in this genre,
created way back in the 80's
(in fact curses was originally developed <i>for</i> rogue).
Sometimes the ancient <samp>rogue</samp>,
<samp>hack</samp> or <samp>larn</samp> are included in the <samp>bsdgames</samp> package,
but players today usually prefer more modern alternatives.
</p>

<p>
The arch typical roguelike of all time is <samp>nethack</samp>,
which might very well be the
<a href="https://www.linuxvoice.com/nethack">greatest game</a>
ever created!
It has been in continuous development for over 30 years
(40 if you include the predecessors it is based on),
and has surprising depth.
You owe it to yourself to die at least once playing this murderously difficult dungeon crawler before you snuff it for good in RL.
Other popular alternatives is the action focused <samp>crawl</samp>,
the meta-world games of <samp>adom</samp> and <samp>angband</samp>,
and the full blown strategy/survival games <samp>dwarffortress</samp> (Linux and FreeBSD only) and <samp>cataclysm</samp>.
(ps: to play dwarffortress in the console,
set <samp>[PRINT_MODE:TEXT]</samp> in <samp>./df/data/init/init.txt</samp>)
</p>

<p>
There are a great,
great many alternative roguelikes out there.
Some of the more obscure ones are also the most interesting,
my own personal favorite for instance is an abandoned scify spin of nethack called <samp>zapm</samp>.
You can browse around in
<a href="http://www.roguebasin.com">roguebasin</a>
for more options if you are curious.
</p>

<h3 id="if">Interactive Fiction</h3>

<p>
Way back in the 70's the legendary game developer Infocom produces a host of interactive fiction games.
These games are all text,
like an interactive novel.
Now,
I know what you are thinking:
<i>"What?!?
No graphics?
That cannot be fun!"</i>
Well, that's a bit like saying that a book without pictures cannot be fun.
It's OK to say that if you're 4,
not if you're 40...
To quote one of the Infocom developers in the excellent <i>Get Lamp</i> (2010) documentary:
</p>

<blockquote class="blockquote">
<p>
It's all good with high resolution graphics and surround sound,
but it is still far away from reality.
So what if you make a virtual reality game with 3D glasses?
That's a lot better,
but you don't feel anything.
So how about emerging your body into a sensory simulation capsule.
Now we are getting somewhere!
But it might not feel like the real thing.
So what if we make a direct neural connector to our brain,
feeding it our simulation directly?
Now we can really live out our fantasy!
Of course our imagination could have replaced this high tech solution all along...
</p>
</blockquote>

<p>
To paraphrase Sheldon Couper from The Big Bang Theory,
<em>interactive fiction games runs on the most powerful graphic chip known to man,
your imagination!</em>.
These old games can be played in the command line with <samp>frotz</samp>
(getting the Infocom games legally might be a problem though).
But interactive fiction games are still being created today,
surprising I know,
and most of the newer titles can be obtained for free.
There are even yearly 
<a href="http://ifcomp.org">IF competitions</a>!
</p>

<h3 id="mud">MUD'S</h3>

<p>
As fun as interactive fiction is,
it's an introspective and solitary kind of joy,
much like enjoying a good novel.
Multi User Dungeons,
or <i>MUD's</i>,
on the other hand,
are multiplayer interactive fiction that has been around since the 80's.
Many of these MUD's are still around,
in fact some are huge virtual realms that will take years to explore,
with decades of political history - 
<i>in real time!</i>
Beware:
MUD's are insanely addictive!
</p>

<p>
One suggestion is 
<a href="http://discworld.starturtle.net"><i>Discworld MUD</i></a>,
this MUD recreates Terry Pratchets world in startling detail
(check out the 
<a href="http://dw.daftjunk.com/Ankh-Morpork.png">Ankh-Morpork</a>
city map - each dot here is a playable location!)
You can play the game from the command line with:
<samp>telnet discworld.starturtle.net</samp>.
If you want to have even more enjoyment out of this game,
you can buy any of the 41 discworld novels on Amazon.
Other MUDS are available on
<a href="http://mudconnect.com">mudconnect.com</a>
</p>

<h3 id="edu">Edutainment</h3>

<p>
There isn't much edutainment software for the console,
but there are some.
The bsdgames collection contains a few,
 such as <samp>arithmetic</samp> and <samp>hangman</samp>,
which are fairly self explanatory.
Although having a slightly rude name,
<samp>wtf</samp> is a fairly useful utility,
it explains abbreviations.
And then there is <samp>quiz</samp> which asks you questions and evaluates your responses.
</p>
<p>
By default <samp>quiz</samp> contains questions for various topics,
such as European capital or Presidential terms.
You can either run <samp>quiz European capital</samp> to get the European nations and guess their capitals,
or <samp>quiz capital European</samp> to get the capitals and guess their European nations.
All quizzes can be reversed in this way.
The default questions however are usually very dated,
even using geography names from the Cold-War era,
but you can easily supply your own quiz files,
and this radically increases the programs usefulness as a learning tool!
</p>

<p>
Say you wanted to write a quiz to memorize the console commands used in this howto,
you could add this line to <samp>/usr/share/games/quiz/index</samp>
(it might be located in a different place on your system - check with <samp>locate quiz</samp>):
</p>

<p>
<samp>
/usr/share/games/quiz/console:console_task:command
</samp>
</p>

<p>
Now in the <samp>/usr/share/games/quiz/console</samp> file add these entries:
</p>

<p>
<samp>
<pre>
Watch a video:vlc|mplayer
Play some music:play|mocp
Browse the web:lynx|w3m|links
Read your e-mail:mutt|mail
Read a PDF file:fbi?pdf
View some images:fbi
...
</pre>
</samp>
</p>

<p>
You can now brush up on your console skills with <samp>quiz console_task command</samp>.
Notice that the quiz database allows regex,
so the answer to "Browse the web" is either lynx, w3m or links,
and the answer to "Read a PDF file" is either fbipdf or fbpdf.
You may of course write other more useful quizzes,
such as vocabulary trainers when learning another language,
or quizzes that help you prepare for an exam.
</p>

<p>
Beyond bsdgames,
edutainment software for the console is rare,
but one fine exception is <samp>typespeed</samp>,
which is kind of a touch typing game.
And i suppose the most useful kind of edutainment is simply reading,
a great source of free online books can be found at <samp>gutenberg.org</samp>.
You can read these online with <samp>lynx</samp> or download them and read them in <samp>less</samp>.
Of course if you really want to challenge your brain muscles,
learn to program,
and write edutainment software yourself to fill this void :)
</p>

<h3 id="misc">Misc Fun</h3>

<p>
<a href="images/asciiquarium.png"><img src="thumbs/asciiquarium.png" title="This aquarium does not require water cooling"></a>
</p>

<p>
You can have much geeky fun in the console beyond pure gaming.
<samp>fortune</samp> is a classic command from the bsdgames collection that produces random quotations and humorous snippets.
It's quite popular to add this program to <samp>/etc/motd</samp> or your shell configuration file,
so that you are always greeted with a random welcome message when you log in.
You can also pipe this output (or other text) to various fun filters such as:
</p>
<p>
<ul>
  <li><samp>cowsay</samp> - draws an ascii cartoon around the text</li>
  <li><samp>figlet</samp> (or <samp>toilet</samp>), or banner from the bsdgames collection - converts the text to asciiart banners
  <li><samp>lolcat</samp> - adds spectacular colors to the text
  <li>one of the filter from <samp>textfilters</samp> (or <samp>filters</samp>) such as <samp>pirate</samp> - that converts the text to pirate slang</li>
  <li><samp>rot13</samp> or <samp>pig</samp> from the bsdgames collection - obfuscate the text</li>
</ul>
</p>

<p>
If you want to produce a random quote with a random cow
(<samp>cowsay</samp> has many different "cows" to choose from),
you can do so with this script:
</p>

<p>
<pre>
<samp>
#!/bin/sh
# cowfortune - fortune with random cow
# usage: cowfortune
COWDIR=/usr/share/cowsay/cows
COWFILE=$(ls -1 $COWDIR | shuf | head -n 1)
fortune | cowsay -f $COWFILE
</samp>
</pre>
</p>

<p>
PS: Beware that some systems include offensive asciiart with sexual content,
whereas others have censored out these cows from the collection.
So printing a random "cow" may not be what you want.
You can always manually delete any of the cow files that offends you though.
</p>

<p>
You could also do something like this:
<samp>fortune | pirate | cowsay -f $(ls -l /usr/share/cowsay/cows | shuf | head -n 1) | lolcat</samp>
Have fun :^)
</p>

<p>
If you're into asciiart you will probably enjoy the "screensavers" <samp>cmatrix</samp> and <samp>asciiquarium</samp>.
The bsdgames collection also has a few that you can try out,
such as <samp>worms -t -d 50</samp> or <samp>rain -d 150</samp>.
</p>

<p>
Another fun command is <samp>sl</samp>,
which animates a steam locomotive in ascii traveling across your screen.
The joke is that <samp>ls</samp> is probably the command you type the most,
it's easy to mistype it as <samp>sl</samp>,
and when you do the steam locomotive will grieve you for several seconds...
</p>

<p>
FreeBSD has a nice program in its repo called <samp>coffeebreak</samp>.
It's just a shell script that runs a bunch of important looking sysadmin commands that does nothing.
The idea is to run <samp>coffeebreak</samp> at work whenever you need a break,
it looks like you are just waiting for something important to finish.
Other operating systems do not have this program,
but seasoned sysadmins can easily create such a script themselves.
Here is one simple way to do it:
Install and run <samp>ttyrec</samp>.
Now compile a bunch of stuff,
and type <samp>exit</samp> when you are done.
You can then,
<samp>mv ttyrecord ~/.coffeebreak</samp>,
and add this to <samp>~/.profile</samp> (or <samp>~/.bashrc</samp>):
<samp>alias coffeebreak='while true; do ttyplay ~/.coffeebreak'; done</samp>
You now have your very own <samp>coffeebreak</samp> script!
To quit the playback,
hit <kbd>Ctrl</kbd> + <kbd>c</kbd>.
</p>

<p>
There are also various easter eggs in Linux land.
A popular example is to add <samp>Defaults Insults</samp> in <samp>/etc/sudoers</samp>,
which will make sudo rather obnoxious if you mistype your password.
Naturally you can make your own internal dad jokes too,
I often have the following in my <samp>~/.bashrc</samp>:
</p>

<p>
<samp>
<pre>
# quirky humor
alias playdead=halt
alias lazarus=reboot
alias woman=man
alias dog=cat
...
</pre>
</samp>
</p>

<p>
Judging from various terminal screenshots on the web,
many people seem to like <samp>linux_logo</samp> (or <samp>neofetch</samp>)
and <samp>tty_clock</samp>
(OpenBSD has its own version of this called <samp>grdc</samp>).
It is easy enough to write scripts with similar functionality yourself though.
You could for instance just create an ASCII art logo,
possibly with the aid of the aforementioned <samp>figlet</samp>.
You can then colorize it with <samp>lolcat</samp>.
As for the digital clock you can add the command <samp>cliclock</samp>,
which does much the same as tty_clock,
and <samp>topclock</samp>,
which will add a digital clock to the upper right corner for your terminal
(and you can still use your terminal normally),
by adding the following aliases to your shell configuration (eg. <samp>~/.bashrc</samp>):
</p>

<p>
<pre>
<samp>
alias cliclock='while sleep 1; do clear; date "+%H:%M:%S" | figlet -f smslant; done'
alias topclock='while sleep 1; do tput sc; tput cup 0 $(($tput cols)-8)); date "+%H:%M:%S"; tput rc; done &'
</samp>
</pre>
</p>

<p>
You can do a whole lot of fun with <samp>telnet</samp>,
even in 2018!
Here are some suggestions:
<ul>
  <li><samp>telnet towel.blinkenlights.nl</samp>: watch StarWars IV in Ascii</li>
  <li><samp>telnet telehack.com</samp>, then <samp>eliza</samp>: talk with a psychotherapist</li>
  <li><samp>telnet freechess.org</samp>: play chess</li>
  <li><samp>telnet rainmaker.wunderground.com</samp>: display weather forecast</li>
  <li><samp>ssh sshtron.zachlatter.com</samp>: multiplayer racing game</li>
</ul>
</p>

<h2 id="office">Office</h2>

<p>
<a href="images/office.png"><img src="thumbs/office.png" title="Enjoy distraction free writing that only typewriters and the console can provide"></a>
</p>

<h3 id="documents">Reading Documents</h3>

<p>
The arch typical program for reading documents on the command line is <samp>less</samp>,
and for many UNIX users it is a well known tool for text reading.
What may come as a surprise though is that less can read a lot more than plain text files.
This is due to the fact that less allow a user to specify a preprocessor with the <samp>LESSOPEN</samp> environment variable.
Thus, 
any file that can be converted to text by some other program,
can be viewed automatically in less with the right configuration in place.
On most UNIX systems this preprocessor is set to <samp>/usr/local/bin/lesspipe.sh</samp> or a similar script,
which allows less to do a few fancy things like read the contents of a tar archive.
You can manually expand the <samp>lesspipe.sh</samp> script,
or even wholesale replace it,
to suit your viewing needs.
</p>

<p>
A nice github project that exploits this is 
<a href="https://github.com/wofr06/lesspipe">here</a>.
When you run the provided <samp>./configure</samp> script,
it checks to see if you have tools such as:
<samp>antiword</samp> to read Microsoft Word documents.
<samp>xlhtml</samp> to read MS Excel documents.
<samp>pdftotext</samp>, (from <samp>poppler-utils</samp>) which can read PDF documents.
And more.
When it has figured out what tools you have available,
it builds a corresponding <samp>lesspipe.sh</samp> script and a few helper scripts.
You can then install them simply by running <samp>sudo cp lesspipe.sh sxw2txt code2color tarcolor /usr/local/bin</samp>,
or other suitable location.
(make sure your <samp>LESSOPEN</samp> variable points to the correct script. eg. add <samp>export LESSOPEN="|/usr/local/bin/lesspipe.sh %s"</samp> to your <samp>~/.profile</samp> or <samp>~/.bashrc</samp>)
</p>

<p>
With this in place you should be able to read quite a few documents with less.
But be aware that the quality of document to text rendering varies.
There is excellent support for old Microsoft office documents for instance,
but not for new ones.
The rendering of PDF's will vary depending on the file in question,
but it's usually not very good.
If you have a framebuffer device available,
your best bet is probably to convert your office documents to PDF and read them directly with a PDF reader such as <samp>fbipdf</samp>.
And HTML is easy enough to read in a browser such as <samp>lynx</samp>.
</p>

<h4 id="libreoffice">LibreOffice</h4>

<p>
The above script has one flaw, it is rather dated.
Worse, the tools needed to convert Microsoft Office documents are even less maintained.
Luckily LibreOffice has excellent support for converting different document formats,
and you can use it without the pesky GUI.
Here are some examples:
</p>

<p>
<pre>
<samp>
$ <i>soffice --headless --convert-to pdf mydoc.docx ; fbipdf mydoc.pdf</i>
$ <i>soffice --headless --convert-to html mydoc.docx ; lynx mydoc.html</i>
$ <i>soffice --headless --convert-to odt mydoc.docx ; odt2txt mydoc.odt</i>
</samp>
</pre>
</p>

<h4 id="epub">E-Books</h4>

<p>
Epubs are actually just zipped html files,
so in theory you can unzip the file and read the results with <samp>lynx</samp> or another browser.
In practice though it can be quite a mess to figure out which files correspond to the chapters you want.
<a href="http://devio.us/~dan/scripts/unix/sources/bin/eread">Here</a> is a script I made that tries to sort this out automatically.
It's crude, but works quite well in many cases.
You are welcome to try it (and improve it...).
</p>

<p>
Other ebook formats may not be that easy to read manually.
If you have installed <samp>calibre</samp>,
it comes with the <samp>ebook-convert</samp> command line tool,
which you can use to convert the ebook file into another format.
Some examples:
</p>

<p>
<pre>
<samp>
$ <i>ebook-convert mydoc.mobi mydoc.pdf ; fbipdf mydoc.pdf</i>
$ <i>ebook-convert mydoc.mobi mydoc.html ; lynx mydoc.html</i>
$ <i>ebook-convert mydoc.mobi mydoc.txt ; cat mydoc.txt</i>
</samp>
</pre>
</p>

<h4 id="cbr">CBR Comic Books</h4>

<p>
CBR comic books are just images archived with rar,
you can read them in the console by <samp>unrar</samp>'ing the file and then view the images with <samp>fbi</samp> if you have a framebuffer device available
(cbz files are zipped images, so use <samp>unzip</samp> on them).
</p>

<h3 id="spelling">Writing Text and Spell Checking</h3>

<p>
There is a ridiculous amount of text editors available for UNIX.
A popular editor for beginners is <samp>nano</samp>
(or <samp>ee</samp> in the BSD world),
you can freely move about with the cursor keys and type in your text.
When you are done hit <kbd>Ctrl</kbd> + <kbd>x</kbd> to quit,
the editor will ask if you want to save your work,
hit <kbd>y</kbd> for yes if you do.
You can see a quick menu of the most common file operation commands at the bottom,
<samp>^X Exit</samp> for instance means hit <kbd>Ctrl</kbd> + <kbd>x</kbd> to exit.
</p>

<p>
You can spell check your files interactively with <samp>aspell -c myfile</samp>,
or <samp>aspell -l lang -c myfile</samp>,
if you need to specify the language.
</p>

<p>
Not all UNIX'es come with <samp>aspell</samp> (or <samp>ispell</samp>/<samp>hunspell</samp>/etc...) by default,
but virtually all come with the classic spell checker <i>spell</i>.
<samp>Spell</samp> is a very simple program.
It checks if your words are found in the systems plain text dictionary
(usually in <samp>/usr/share/dict/words</samp>),
if not it just prints the presumably misspelled word.
By the way you can manually check for words in this dictionary with the
<samp>look</samp>
command.
Using <samp>spell</samp> may at first seem to be very inefficient,
since it just hands you a long list of words that you need to manually check and correct yourself.
But for precisely that reason it is actually very efficient at teaching you correct spelling...
</p>

<p>
The classic text editors on UNIX are <samp>emacs</samp> 
(see <samp>mg</samp> for OpenBSD),
and <samp>vi</samp>.
Emacs is notorious for being over engineered,
it can read your email and browse the web,
not to mention play games,
it can even edit text files!
Vi on the other hand is notorious for being overly complex to use.
You need to learn quite a few keyboard commands in order to use it,
and you need to navigate back and forth between different modes.
Both of these editors will require some effort to learn,
but they are extremely useful when mastered.
If you want to become a productive UNIX user,
learn one of them!
</p>

<p>
<img src="thumbs/editor_learning_curves.png" title="choose your preferred learning curve"></a>
</p>

<p>
By the way both <samp>vim</samp>
(<samp>vi</samp> improved)
and <samp>Emacs</samp> have internal spell checkers you can use,
<samp>:set spell</samp> for <samp>vim</samp>, and <kbd>Alt</kbd> + <kbd>x</kbd> <samp>ispell-buffer</samp> for <samp>Emacs</samp>.
But it's just as easy to use <samp>aspell</samp> from within <samp>vi</samp>/<samp>vim</samp> by running
<samp>:!aspell -c myfile</samp>
(the <samp>Emacs</samp> <samp>ispell</samp> command actually uses <samp>aspell</samp> as its backend).
</p>

<h3 id="dictionary">Dictionaries</h3>

<p>
<i>WordNet</i> is a very good English dictionary,
you can lookup a word from the command line like so:
<samp>wn flabbergasted -over</samp> 
(over means "overview").
Sadly there arn't many such alternatives for languages other then English,
but you may be able to find a free online dictionary,
and if you are lucky it might even work in <samp>lynx</samp>.
</p>

<p>
Way back in the 70's UNIX came with the Writer's Workbench suit of tools.
Today much of this functionality has been continued with the GNU tools 
<samp>diction</samp> and <samp>style</samp>.
These tools do basic sanity checks of your documents,
such as checking if two identical words are written right next to each other.
And <samp>style</samp> does a basic analysis of your prose.
Of course the tools cannot actually make you a good writer,
but they are handy utilities nonetheless
(they only support English and German).
And like all the classic UNIX tools,
it pays great dividends to split your work into many small files
(eg. <samp>cat chap* > book</samp>),
otherwise the output from these commands will be overwhelming.
</p>

<h3 id="writing">Writing Documents</h3>

<p>
<a href="images/word.png"><img src="thumbs/word.png" title="Docs can be written in Wordgrinder, or any text editor for that matter"></a>
</p>


<p>
The closest console equivalent to a typical "word processor" is <samp>wordgrinder</samp>.
It is basically Word Pad for the terminal,
so it lets you add a few basic extras to your text documents,
such as underlined text,
chapter headers or bullet points.
Just hit Esc to bring up the main menu.
It uses it's own fileformat by default,
but you can export this to other formats,
such as ODT, LaTeX or HTML.
A slightly more professional way to write your documents though,
would be to type them directly in a markup language in a text editor,
and then converting the source files to document format,
such as a PDF.
Beyond amateur HTML (and *ahem* Markdown),
there are several candidates available to you.
Here are three examples:
</p>

<h4 id="troff">Troff</h4>

<p>
<samp>troff</samp> is the markup language used to write man pages in UNIX,
and as such it isn't very impressive.
The man pages are just plain text with little formatting finesse.
This however is not because troff is primitive,
but rather that the terminal <i>is</i>.
By default troff writes postscript files as its output,
intended for printers.
If you write a man page in this output,
you will see that the humble man page actually looks very much like a professional document:
</p>

<p>
<pre>
<samp>
$ <i>cp /usr/man/man1/ls.1.gz /tmp && cd /tmp</i>
$ <i>gunzip ls.1.gz</i>
$ <i>groff -m man -T pdf ls.1 > ls.pdf</i>
$ <i>fbipdf ls.pdf</i>
</samp>
</pre>
</p>

<p>
Of course it still looks like a man page,
as it should since its written with the <samp>man</samp> macro package
(pure troff markup is very low level,
you usually write documents with higher level macro commands).
But troff is capable of producing other document types as well.
Several computer text books have been written in troff.
Naturally this includes the UNIX classics such as 
<i>The C Programming Language</i> and <i>The UNIX Programming Environment</i>,
but also some modern works such as 
<i>The Design and Implementation of the FreeBSD Operating System</i>.
These books contain indexes, footnotes, graphs, diagrams, pictures,
tables and most confections you would expect to find in professional literature
(troff's complete lack of comic sans and clip-arts reinforces the professional vibe).
</p>

<p>
A popular troff macro package for general purpose documents is <samp>ms</samp>.
Here is an example letter written in ms:
</p>

<p>
<pre>
<samp>
.LP
.DS L
To: Archduke Poggle of Geonosis
23 Insectoid Str.
Hive
103133
GEONOSIS
.DE
.DS L
From: Emperor Palpatine
Imperial Palace
PO 000001
Senate District
CORUSCANT
.DE
.SH
Dear Archduke
.PP
The so called
.I 
undefeatable
.R
Death Star was blown to bits by a bunch of teenagers yesterday.
I must say I am disappointed!
We need to construct a new planet killer ASAP,
and this time lets try to avoid an
.B
Achilles heel
.R
in our design shall we?
.PP
I have some other ideas for further improvements.
First of all we need a 
.I
menacing 
.R
throne room with a view...
</samp>
</pre>
</p>

<p>
The syntax here is fairly simple.
You first write an <samp>ms</samp> command,
which all begin with a dot, 
such as <samp>.SH</samp> (a section header).
This command is then applied to the following text,
until you encounter another <samp>ms</samp> command.
You will find troff included by default on virtually every UNIX system,
and it is a simple document system that is indispensable for system administrators,
and surprisingly useful for casual use.
Another advantage of troff is that its syntax fits very well with the line based UNIX tools,
for instance to convert a troff file to plain text you would only need to do this:
<samp>cat mydoc.ms | sed '/\..*/d' | fmt</samp>
</p>

<p>
You can convert the above ms source file to various document formats,
such as a PDF:
<samp>groff -m ms -T pdf mydoc.ms > mydoc.pdf</samp>
It will look like this:
</p>

<p>
<a href="https://pspodcasting.net/images/dan/blog/2018/troff.png"><img src="thumbs/troff.png" title="Palpatines letter in troff"></a>
</p>

<p>
Some important <samp>ms</samp> macros:
<br>
<b>.PP</b> Paragraph, normal text and many other macros <i>require</i> an initial .PP (or .LP)
<br>
<b>.LP</b> Left adjusted Paragraph
<br>
<b>.TL</b> Document Title, normally the first macro
<br>
<b>.SH</b> Section Header
<br>
<b>.NH</b> automatically Numbered section Header
<br>
<b>.DA</b> Date line
<br>
<b>.DS</b> Start Displayed text, newlines and white space is taken literally
<br>
<b>.DE</b> End Displayed text
<br>
<b>.FS</b> Start Footnote
<br>
<b>.FE</b> End Footnote
<br>
<b>.B</b> Bold font
<br>
<b>.I</b> Italicize font
<br>
<b>.CW</b> Constant Width (aka typewriter) font
<br>
<b>.R</b> Roman (ei. regular) font
<br>
<b>.br</b> Force a linebreak (raw troff command, not an ms macro)
</i>
</p>

<p>
Ironically the markup language used to write UNIX manuals,
troff,
is not well documented.
This has mainly to do with the fact that it did not catch on as a general purpose documentation tool outside of Bell Labs.
Still,
the old Bell Labs papers on these tools are very useful references,
even for modern versions of these programs.
<i>PS</i>:
Linux systems today use <samp>groff</samp> and BSD systems use <samp>mandoc</samp>,
but both are essentially backwards compatible with the original UNIX <samp>troff</samp>.
Mandoc however can only render manpages,
so install <samp>groff</samp> as well on BSD systems if you plan to write generic troff documents.
If you need to write an actual man page,
check man 7 man.
There are also a number of troff preprocessors that can add specific functionality,
most of them have fairly decent man pages.
In the list below you will also find links to the old Bell Labs papers on these tools:
</p>

<p>
<samp><a href="docs/troffref.pdf">troff</a></samp> - Reference manual
<br>
<samp><a href="docs/trofftut.pdf">troff</a></samp> - Tutorial
<br>
<samp><a href="docs/ms.pdf">ms</a></samp> - Ms article macros for troff
<br>
<samp><a href="docs/tbl.pdf">tbl</a></samp> - Add tables to troff
<br>
<samp><a href="docs/eqn.pdf">eqn</a></samp> - Add mathematical equations
<br>
<samp><a href="docs/pic.pdf">pic</a></samp> - Add basic drawings/diagrams
<br>
<samp><a href="docs/grap.pdf">grap</a></samp> - Add graphs
<br>
<samp><a href="docs/refer.pdf">refer</a></samp> - Add reference indexes
</p>

<h4 id="tex">Tex</h4>

<p>
Perhaps the most widely used document system on UNIX is <samp>Tex</samp>
(<samp>latex</samp> is a dialect of Tex).
It was originally written because it's author was annoyed by the limitations of troff.
Tex has become quite popular in the scientific community,
and it is not unusual for universities to require students to send in their papers in this format.
Of course you can also use Tex to write your personal letters and todo lists.
Although Tex is not normally included by default in UNIX systems,
you can usually install a Tex distribution, 
like the <samp>texlive-base</samp> or a similar package,
with the systems package manager
(<i>PS</i>:
Unlike troff,
Tex is a <i>large</i> package,
it can take more than a gigabyte of diskspace!
(that's like a <i>thousand</i> floppy disks!!!)).
The above example letter in Tex would be written like this:
</p>

<p>
<pre>
<samp>
\documentclass{article}
\begin{document}

\begin{verbatim}
To: Archduke Poggle of Geonosis
23 Insectoid Str.
Hive
103133
GEONOSIS
\end{verbatim}

\begin{verbatim}
From: Emperor Palpatine
Imperial Palace
PO 000001
Senate District
CORUSCANT
\end{verbatim}

\section*{Dear Archduke}

The so called \emph{undefeatable} Death Star was blown to bits by a bunch of teenagers yesterday.
I must say I am disappointed!
We need to construct a new planet killer ASAP,
and this time lets try to avoid an \textbf{Achilles heel} in our design shall we?

I have some other ideas for further improvements.
First of all we need a \emph{menacing} throne room with a view..

\end{document}
</samp>
</pre>
</p>

<p>
As you can see the Tex syntax is more free form,
where you can intersperse normal text with formatting commands.
You can convert the Tex source file to more useful document types,
such as a PDF:
<pre>
<samp>
$ <i>latex mydoc.tex </i>
$ <i>dvipdf mydoc.dvi</i>
</samp>
</pre>
(<i>PS</i>:
Tex is very particular about its syntax,
latex will fail to compile the document for instance if you leave out
the <samp>\end{document}</samp> line at the end).
It will look like this:
</p>

<p>
<a href="https://pspodcasting.net/images/dan/blog/2018/tex.png"><img src="thumbs/tex.png" title="Palpatines letter in tex"></a>
</p>

<p>
The Tex equivalents to the above mentioned ms macros:
<br>
<b>\par</b> Paragraph, normally you just separate paragraphs with empty lines though.
<br>
<b>\noindent</b> Suppress line indentation, or force it with <b>\indent</b>
<br>
<b>\section{}</b> Section header, suppress automatic numbering with <b>\section*{}</b>
<br>
<b>\date</b> Write todays date
<br>
<b>\begin{verbatim}</b> Start literal text block, white space printed as is
<br>
<b>\end{verbatim}</b> End literal text block
<br>
<b>\footnote{}</b> Add a footnote
<br>
<b>\textbf{}</b> Text in bold font
<br>
<b>\emph{}</b> Emphasized, or italicized, font
<br>
<b>\texttt{}</b> Typewriter, or constant width, font
<br>
<b>\linebreak</b> Force a linebreak
</p>

<p>
You can probably find a useful Tex tutorial with a quick Google search
(although <samp>latex</samp> might give you some unwarranted results),
and there are several useful books on the subject available on Amazon.
</p>

<h4 id="docbook">Docbook</h4>

<p>
The other serious competitor to Tex (in terms of popularity at least), 
is Docbook.
It is basically HTML for books.
Which may or may not be a good thing,
depending on your background
(ei. if you are a script kiddie or not).
Here is an example of how you could write the above letter:
</p>

<p>
<pre>
<samp>
&lt;!DOCTYPE article PUBLIC "-//OASIS/DTD DocBook XML V4.5//EN" "/usr/share/xml/docbook/xml-dtd-4.5/docbookx.dtd"&gt;
&lt;article&gt;
  &lt;section&gt;
    &lt;para&gt;
      &lt;literallayout&gt;
        To: Archduke Poggle of Geonosis
        23 Insectoid Str.
        Hive
        103133
        GEONOSIS
      &lt;/literallayout&gt;
    &lt;/para&gt;
  &lt;/section&gt;

  &lt;section&gt;
    &lt;para&gt;
      &lt;literallayout&gt;
        From: Emperor Palpatine
        Imperial Palace
        P0 000001
        Senate District
        CORUSCANT
      &lt;/literallayout&gt;
    &lt;/para&gt;
  &lt;/section&gt;

  &lt;section&gt;
    &lt;title&gt;Dear Archduke/title&gt;
    &lt;para&gt;
      The so called &lt;emphasis&gt;undefeatable&lt;/emphasis&gt; Death Star was
      blown to bits by a bunch of teenagers yesterday. I must say I am
      disappointed! We need to construct a new planet killer ASAP, and
      this time lets try to avoid an &lt;emphasis role="bold"&gt;Achilles
      heel&lt;/emphasis&gt; in our design shall we? I have some other ideas
      for further improvements. First of all we need a menacing throne
      room with a view...
    &lt;/para&gt;
  &lt;/section&gt;
&lt;/article&gt;
</samp>
</pre>
</p>

<p>
We can now convert this source document into html or other formats,
for example assuming you saved this letter as <i>letter.xml</i> you can:
</p>

<p>
<pre>
<samp>
$ <i>STYLEST=/usr/share/xml/docbook/xsl-stylesheets-1.78.1/html/docbook.xsl</i>
$ <i>xsltproc -o letter.html $STYLEST letter.xml</i>
</samp>
</pre>
</p>

<p>
The result will look similar (browser dependent) to this:
</p>

<p>
<a href="https://pspodcasting.net/images/dan/blog/2018/docbook.png"><img src="thumbs/docbook.png" title="Palpatines letter in Docbook"></a>
</p>

<p>
There is a bewildering plethora of different docbook tools available,
and the method used to produce docbook documents can vary greatly.
This is just an example.
Also note that the <i>docbookx.dtd</i> and <i>docbook.xsl</i> files used here can be located in different places on different systems, 
check with <samp>locate docbookx.dtd docbook.xsl</samp>
(You might need to install a package or two to get them).
</p>

<p>
The Docbook equivalents to the above mentioned Tex commands:
<br>
(as with HTML Docbook tags such as &lt;para&gt; must end with a closing tag,
in this case &lt;/para&gt;)
<br>
<b>&lt;para&gt;</b> Paragraph, note that this must be within a &lt;section&gt; tag, within a &lt;article&gt; tag (assuming you are writing an article)
<br>
<b>&lt;title&gt;</b> Section Header, must be within a &lt;section&gt; tag.
<br>
<b>&lt;?dbtimestamp format="Y-m-d"?&gt;</b> Print current date.
<br>
<b>&lt;literallayout&gt;</b> Read paragraph literally, preserving spacing and linebreaks.
<br>
<b>&lt;emphasis role="bold"&gt;</b> Text in bold font
<br>
<b>&lt;emphasis&gt;</b> Emphasized, or italicized (usually...), font
<br>
<b>&lt;computeroutput&gt;</b> Constant Width fonts (usually).
</p>

<p>
Writing left-aligned paragraphs, numbered paragraphs, footnotes or linebreaks,
can be done with various clever hacks, that is anything but intuitive.
Buy a book an Amazon or search the web for tutorials to get the gory details,
or better yet,
choose a different markup language to write your documents in.
</p>

<h3 id="spreadsheets">Spreadsheets and Databases</h3>

<p>
<a href="images/sheet.png"><img src="thumbs/sheet.png" title="Juvenile delinquents accounting"></a>
</p>

<p>
<samp>sc</samp> is quite a decent spreadsheet for the console.
It has its own way of doing things though,
so initially you will want to hit <samp>?</samp> and spend some time learning the ropes.
Sc uses its own file format by default,
but it can export to LaTex or tbl (ei. troff) too.
Of course <samp>sc</samp> is a poor substitute for Excel,
but then again,
Excel is a poor substitute for a database.
And there are many professional databases available for UNIX,
such as <samp>MariaDB</samp> and <samp>PostgreSQL</samp>.
For private use though <samp>Sqlite</samp> is probably sufficient:
</p>

<h4 id="sqlite">Sqlite</h4>

<p>
Let's apply a popular spreadsheet pass time to our SQL database,
making a budget and doing our accounting:
</p>

<p>
<pre>
<samp>
$ <i>sqlite3 account.db</i>
sqlite> <i>CREATE TABLE account ( id INTEGER PRIMARY KEY, date TEXT DEFAULT CURRENT_DATE,</i>
   ...> <i>category TEXT DEFAULT 'food', price INTEGER NOT NULL, desc TEXT );</i>
sqlite> <i>INSERT INTO account ( category, price, desc ) VALUES ( 'sweets', 1.25, 'coca cola' );</i>
sqlite> <i>INSERT INTO account ( category, price, desc ) VALUES ( 'sweets', 2.95, 'candy bar' );</i>
sqlite> <i>INSERT INTO account ( date, price ) VALUES ( '2018-04-25', 20.65 );</i>
sqlite> <i>.headers on</i>
sqlite> <i>.mode column</i>
sqlite> <i>SELECT * FROM account ORDER BY date;</i>
</samp>
</pre>
</p>

<p>
This will produce an output similar to this:
</p>

<p>
<samp>
<table>
<tr>
<td>id</td>
<td>date</td>
<td>category</td>
<td>price</td>
<td>desc</td>
</tr>
<tr>
<td>----------------</td>
<td>----------------</td>
<td>----------------</td>
<td>----------------</td>
<td>----------------</td>
</tr>
<tr>
<td>3</td>
<td>2018-04-25</td>
<td>food</td>
<td>0.65</td>
<td>chewing gum</td>
</tr>
<tr>
<td>1</td>
<td>2018-04-26</td>
<td>sweets</td>
<td>1.25</td>
<td>coca cola</td>
</tr>
<tr>
<td>2</td>
<td>2018-04-26</td>
<td>sweets</td>
<td>2.95</td>
<td>candy bar</td>
</tr>
</table>
</samp>
</p>

<p>
With this database in place you can list particular types of expenses:
<samp>SELECT * FROM account WHERE category = 'sweets';</samp>,
or summarize them:
<samp>SELECT sum(price) AS total FROM account WHERE category = 'sweets';</samp>.
Type <samp>.help</samp> for more instructions,
and <samp>.quit</samp> to exit SQLite.
Using SQL databases from a shell script is also quite trivial.
Here is a simple example:
</p>

<p>
<pre>
<samp>
#!/bin/sh
# sqlaccount - manage an sql account
# usage: sqlaccount [-d date] [-c category] [-s category] [amount comments...]

database=$HOME/account.db
if [ ! -f $database ]; then
	echo "CREATE TABLE account ( id INTEGER PRIMARY KEY, date TEXT DEFAULT CURRENT_DATE, category TEXT DEFAULT 'food', price INTEGER NOT NULL, desc TEXT );" | sqlite3 $database
fi

if [ $# = 0 ]; then
	echo "SELECT * FROM account ORDER BY date;" | sqlite3 -column $database
	exit
fi

date=$(date "+%Y-%m-%d")
category=food
for args in "$@"; do
	case "$args" in
		-d) date=$2 ; shift 2 ;;
		-c) category=$2 ; shift 2 ;;
		-s)
			if [ $# = 1 ]; then
				echo "SELECT sum(price) AS total FROM account;" | sqlite3 -column $database
			else
				echo "SELECT sum(price) AS total FROM account WHERE category = '$2';" | sqlite3 -column $database
			fi
			exit ;;
	esac
done
price=$1
shift

echo "INSERT INTO account ( date, category, price, desc ) VALUES ( '$date', '$category', $price, '$@');" | sqlite3 $database
</samp>
</pre>
</p>

<p>
You can now do something like this:
</p>

<p>
<pre>
<samp>
$ <i>sqlaccount -c sweets 1.25 coca cola</i>
$ <i>sqlaccount -c sweets 2.95 candy bar</i>
$ <i>sqlaccount -d 2018-04-25 20.65</i>
$ <i>sqlaccount</i>
3 2018-04-25 food   20.65
1 2018-04-26 sweets 1.25  coca cola
2 2018-04-26 sweets 2.95  candy bar
$ <i>sqlaccount -s</i>
24.85
$ <i>sqlaccount -s sweets</i>
4.2
</samp>
</pre>
</p>

<p>
There is a whole heck of a lot you can do with an SQL database,
we have only scratched at the very surface here.
There are many fine books on this subject on Amazon,
and I am sure you can find a useful tutorial if you Google for it.
It does require some effort to learn SQL,
but once you have done so,
you will never need a spreadsheet again!
</p>

<h4 id="awk">AWK</h4>

<p>
You may feel that the above example was far too complicated,
you are absolutely right.
In fact if you ever see anyone doing their personal accounting in an SQL database,
slap them
(one exaggeration deserves another)!
It is in fact quite simple to just type in your account information in a plain text editor,
and summarize them or query the accounts with sed or awk.
Consider this example:
</p>

<p>
<pre>
<samp>
2018-04-25 food 20.65
2018-04-26 sweets 1.25 coca cola
2018-04-26 sweets 2.95 candy bar
</samp>
</pre>
</p>

<p>
You can list all account records for April 2018 by:
<samp>sed -n '/^2018-04/p' account.txt</samp>,
or summarize the march expenses by:
<samp>awk '/^2018-04/ { sum+=$3 } END { print sum }' account.txt</samp>.
Or if you only want to summarize your candy expenditures for April:
<samp>awk '/^2018-04.* sweets/ { sum+=$3 } END { print sum }' account.txt</samp>.
A more elaborate example of an accounting shell script can be found in the
<a href="#accounting">Accounting section</a>.
</p>

<p>
Do not be quick to dismiss <samp>awk</samp>,
it can do much more then you think.
In section 4.3 of the classic book <i>The AWK Programming Language</i>,
for example
(if you don't have this in your bookshelf - <i>get it!</i>),
the authors demonstrate how a ~50 line awk script enables you to create a relational database spread across multiple files,
using column name tags instead of numbers.
Awk is also <i>fast</i>,
unless you are planning to develop a website with hundreds of requests per second,
industry grade databases will not give you any significant speed improvements.
Best of all,
when you have mastered awk,
you will find a million other uses for this versatile utility!
</p>

<h3 id="presentation">Presentations</h3>

<p>
<a href="images/tpp.png"><img src="thumbs/tpp.png" title="Tacky slide show using TPP"></a>
</p>

<p>
It is odd that businessmen place so much emphasis on presentations,
when they are really just a slideshow of pictures,
lightly sprinkled with semi-relevant text.
There are presentation specific software for the console,
such as <samp>tpp</samp>,
you can also create slides with <samp>tex</samp> or even <samp>troff</samp>.
Another approach is to create a bunch of images with sequential names (eg 001.jpg, 002.jpg, etc...),
and view them with an image viewer like <samp>fbi</samp>
(you can add text to the pictures with ImageMagick if you like).
</p>

<p>
If you want to give tpp a go,
read the instructions in <samp>/usr/share/doc/tpp/README</samp>
(it might be located somewhere else on your system).
It's fairly straight forwards.
TPP uses its own file format,
ut it can also export to LaTex.
The above tpp screenshot was created with this tpp file:
</p>

<p>
<pre>
<samp>
--bgcolor white
--fgcolor magenta

--newpage
--heading A Short Demo of TPP

--withborder
--center Presentations are written as plain text,
--center but you can manipulate the text in various ways.
--center For example, you can change
--boldon 
--color  red
--center font style and color
--boldoff
--## ulon means "underline on", this is a comment btw
--ulon
--color  blue
--center in various ways
--uloff
--color  magenta
--center and you can play around with
--huge   ----Figlet----

--center Thats about it
--center Use the arrow keys or space to move around in the slide show.
--newpage
</samp>
</pre>
</p>

<h3 id="math">Math and Graphs</h3>

<p>
For mathematical tasks,
<samp>bc</samp> is the goto tool.
You can use it interactively or within your scripts.
Just be aware that this calculator doesn't do floating point arithmetic by default,
you can either use the <samp>-l</samp> flag to set the scale to 20 and also enable some advanced mathematical functions 
(sine, cosine, arctangent, logarithms etc...),
or you could just set the scale to the accuracy you need.
To demonstrate:
</p>

<p>
<pre>
<samp>
$ <i>bc -q</i>
<i>20.2 / 10</i>
2
<i>scale=2</i>
<i>20.2 / 10</i>
2.02
<i>quit</i>
$ <i>echo pi = $(echo "4*a(1)" | bc -l)</i>
pi = 3.14159265358979323844
</samp>
</pre>
</p>

<p>
Of course there are other mathematical tools available.
For instance, <samp>dc</samp> is a reverse-polish desk calculator,
if you happen to be a 100 years old and like that sort of thing...
</p>

<p>
As for graphs,
the goto program is <samp>gnuplot</samp>.
This program can do any imaginable thing relating to graphs,
and then some.
But just to get you started,
let take a very simple example:
</p>

<p>
Suppose you have used the above mentioned <samp>sqlaccount</samp> script to check how much expenses you had from January to December in 2017,
and you added these numbers to a text file like so:
</p>

<p>
<pre>
<samp>
01 2104
02 2260
03 1987
04 2053
05 2242
06 2321
07 2107
08 2134
09 2032
10 1934
11 2143
12 2355
</samp>
</pre>
</p>

<p>
You can then use gnuplot to make a graph out of this:
</p>

<p>
<pre>
<samp>
$ <i>gnuplot</i>
gnuplot> <i>set term pngcairo</i> # you may need to use pdfcairo
gnuplot> <i>set title 'Expenditures 2017'</i>
gnuplot> <i>set out 'expenditures.png'</i>
gnuplot> <i>unset key</i>
gnuplot> <i>set grid</i>
gnuplot> <i>plot [1:12] 'months.txt' with line</i>
gnuplot> <i>quit</i>
</samp>
</pre>
</p>

<br>
<p>
<a href="https://pspodcasting.net/images/dan/blog/2018/expenditures.png"><img src="thumbs/expenditures.png" title="a simple graph using gnuplot"></a>
</p>
<p>
<a href="https://pspodcasting.net/images/dan/blog/2018/expenditures_ascii.png"><img src="thumbs/expenditures_ascii.png" title="same graph in ASCII"></a>
</p>

<p>
You can put these instructions in a file and call gnuplot with 
<samp>gnuplot -c mycommands</samp>
to use this program non-interactively.
If you want gnuplot to export a plain ascii graph,
use <samp>set term dumb</samp> instead of <samp>cairopng</samp>.
You can see a full list of output formats by typing <samp>set term</samp> in the gnuplot prompt.
The notation <samp>[1:12]</samp>,
tells gnuplot to begin drawing the graph at x coordinates 1 (January),
and end at x coordinates 12 (December).
Most of the other commands here control what the graph will look like.
Feel free to experiment with these settings.
There are many ways to incorporate gnuplot graphs into your documents.
The simplest is just to export the graph as a picture,
as we did in the above example,
and just include this picture in your document
(exactly how will depend on what document type you want to create).
You can do a <i>lot</i> with gnuplot,
and most distributions also bundle some nice demos that you can play with.
</p> 

<h3 id="mindmap">Mindmaps and Flowcharts</h3>

<p>
You can make simple drawings with document markup languages,
such as <samp>tex</samp> or <samp>troff</samp> (using <samp>pic</samp>).
If however you aren't so much interested in presentation,
but rather the function of mindmaps,
you could just use the filesystem:
</p>

<p>
If you think about it,
the hierarchical filesystem on UNIX <i>is</i> a mindmap of sorts.
And tools such as <samp>ranger</samp> and <samp>tree</samp> can help you visualize it.
See the
<a href="#organize">getting organized</a>
section for ideas.
</p>

<h3 id="pim">PIM</h3>

<p>
Personal Information Management, or PIM,
is a modern buzz word which simply means "getting organized".
What this entails in practice depends very much upon your needs and tastes.
For the minimalist <samp>vi</samp> is really all you need,
but at the other end of the spectrum you have full-blown-command-line-pim-suits,
such as <samp>taskwarrior</samp> (or <samp>task</samp>,
there is also a nice front-end for this, <samp>vit</samp>) 
or <samp>org-mode</samp> for Emacs.
Of course if all you need is a simple todo list,
there are programs for that too,
such as <samp>tdl</samp> and many others.
</p>

<p>
The following sections demonstrate how to write your own simple pim scripts.
These are crude,
the point here is to show you some tricks and perhaps inspire you to create your own variations to suit your needs.
But even basic scripts can be powerful if you follow careful conventions and keep your files organized,
many of these examples
(or variations of them)
are scripts that I use on a daily basis.
</p>

<h4 id="2do">2do lists</h4>

<p>
We'll start of our pim examples by creating a simple 2do list script:
</p>

<p>
<pre>
<samp>
#!/bin/sh
# 2do - a simple 2do list
# usage: 2do [list [ id... | task... ]]

# set some defaults
dir=${dir:-$HOME/.2do}
mkdir -p $dir
date=${date:-$(date +%Y-%m-%d)}

# parse arguments
if [ $# = 0 ]; then
	ls $dir && exit
elif [ $# = 1 ]; then
	grep -v '^#' $dir/$1 | sort -k 2
	exit
fi
list=$1 ; shift
id=1	# id is either 1 or one more then the highest id
if [ -f $dir/$list ]; then
	id=$(awk '{ if($1 > id) id=$1 } END { print id+1 }' $dir/$list)
fi

# id: remove task; task: add it
if (echo "$@" | egrep -q '^[0-9\ ]+$'); then
	for id in "$@"; do
		sed -i "/^$id /s/^/#/" $dir/$list
	done
else
	echo $id $date "$@" >> $dir/$file
fi
</samp>
</pre>
</p>

<p>
And here is a short demonstration of its usage:
</p>

<p>
<pre>
<samp>
$ <i>2do shop buy milk</i>
$ <i>2do shop get eggs</i>
$ <i>2do shop NEED toilet paper ASAP!</i>
$ <i>2do work finish some project</i>
$ <i>2do work start some project</i>
$ <i>2do</i>
shop work
$ <i>2do shop</i>
3 2018-06-22 NEED toilet paper ASAP!
2 2018-06-22 get eggs
1 2018-06-22 buy milk
$ <i>2do work</i>
1 2018-06-22 finish some project
2 2018-06-22 start some project
$ <i>2do shop 3 1</i>
$ <i>2do shop</i>
2 2018-06-22 buy eggs
</samp>
</pre>
</p>

<p>
This 2do script is very basic,
it does not support priorities or tags for instance.
You can only add one task at a time,
and there is no mechanism for deleting a 2do list,
but you can always do that manually:
<samp>rm $HOME/.2do/mylist</samp>.
Naturally,
these 2do lists can also be opened in any plain text editor,
eg. <samp>vi $HOME/.2do/mylist</samp>.
</p>

<p>
You can easily augment this script in various ways.
You could add priorities and tags for instance,
and then sort the lists by priority first,
then by date.
Since tasks aren't actually removed,
but commented out,
it is possible to print an ETA based on number of completed tasks since the list got started.
Feel free to experiment with it.
And once you have made all of these enhancements,
and more,
take a step back and compare your improved version to the original.
Was the extra complexity worth it?
</p>

<h4 id="que">Queues</h4>

<p>
Here is a very simple script,
that I find useful in various situations.
It basically keeps track of a queue,
a plain text list,
where each task is on a line by itself:
</p>

<p>
<pre>
<samp>
#!/bin/sh
# que - a simple queue tracker
# usage: que [-cp] queue

# set some defaults
dir=${dir:-$HOME/.queues}
mark=${mark:-<--}

# parse arguments
if [ $# = 0 ]; then
    ls $dir && exit
fi
while getopts :cpf: opt; do
    case "$opt" in
        c) clear=yes ;;
        p) prcur=yes ;;
        f) file=$OPTARG ;;
        '?') echo "Usage: que [-cp] queue" >&2 && exit 1 ;;
    esac
done
shift $(($OPTIND - 1))
file=${file:-$dir/$1}
if [ ! -f "$file" ]; then
    echo "Error: Queue $file does not exist" >&2 && exit 1
fi

# update the queue
if (grep -q $mark $file); then
    task=$(grep -n $mark $file | sed 's/:.*//')
else
    task=1
fi

if [ "$prcur" = yes ]; then
    if [ $task -gt 1 ]; then
        sed -n "$(($task - 1))p" $file
    fi
    exit
fi
sed -i "s/$mark//" $file
if [ "$clear" = yes ]; then
    exit
fi
sed -n "${task}p" $file
sed -i "$(($task + 1))s/$/$mark/" $file
</samp>
</pre>
</p>

<p>
To use this script you must frist write a queue file in <samp>$HOME/.queues</samp>.
If could for instance be called "homework",
and look like this:
</p>

<p>
<pre>
<samp>
Math: Read chapter 3.12
Math: Do exercises 3.12.1 through 3.12.20
Math: Prep for exam
English: Read the poem from Keats
English: Write essey on Keats
...
</samp>
</pre>
</p>

<p>
If you now run <samp>que homework</samp> it will print
<samp>Math: Read chapter 3.12</samp>,
and the 2nd line of this text file will change to:
<samp>Math: Do exercises 3.12.1 through 3.12.20<--</samp>.
And the next time you run <samp>que homework</samp>,
this line will be printed,
and the arrow mark will be moved to the 3rd line,
and so on.
The concept here is similar to a 2do list,
but useful in situations where you need to do tasks in a sequential order,
such as reading chapters of a book.
I find this script to be very useful if I want to automate such a task.
For instance,
are you following a number of tv shows?
You could write a queue file for Star Trek TOS for instance,
and add this line to your <samp>~/.profile</samp> (or <samp>~/.bashrc</samp>):
<samp>alias tos='mplayer $(que tos)'</samp>.
So that the next time you want to watch Star Trek TOS,
just type <samp>tos</samp>,
and it will automatically play the next episode for you.
</p>

<h4 id="calendar">Calendar</h4>

<p>
The <samp>cal</samp> command can print a calendar if you need it.
To schedule appointments however, the classic UNIX choice is <samp>calendar</samp>.
Practically every version of UNIX has this command,
with just one notable exception: <i>Linux</i>.
Just one of those reminders that this operating system does not really have deep roots in the UNIX world.
Speaking of reminders,
<samp>remind</samp> is a good alternative to <samp>calendar</samp>,
and you can find it in most package repositories.
Remind also has a nice ncurses front-end, <samp>wyrd</samp>.
</p>

<p>
To use <samp>calendar</samp>
(or <samp>remind</samp>)
write your reminders in a plain text file in <samp>~/calendar</samp>.
Your appointments must start with a date, followed by a tab (not a space),
and finally a description that must fit into exactly one line (it can be as long as you want though).
For example:
</p>

<p>
<pre>
<samp>
Jan 03	Give borrowed towel back to neighbor
Apr 27	Dentist appointment - flee the country!
May 04	Star Wars marathon!!!
</samp>
</pre>
</p>

<p>
If you now run the command <samp>calendar</samp>,
and it happens to be April the 26th,
it will print
<samp>Apr 27	Dentist appointment - flee the country!</samp>.
Which will,
at the very least,
give you a days notice to buy plane tickets.
The command will print appointments for today and tomorrow,
or on a Friday,
from Friday through Monday.
Naturally,
the trick to making this useful,
is to set things up so that reminders are automatically printed whenever you log in to your machine,
for example,
by adding this command to <samp>~/.profile</samp> or <samp>~/.bashrc</samp>
(the command
<samp>remind -t1 $HOME/calendar</samp>
will essentially do the same as the above mentioned <samp>calendar</samp> command).
</p>

<h4 id="marking_calendar">Marking The Calendar</h4>

<p>
The classic <samp>calendar</samp> command is great in all its simplicity,
but there is something gratifying about crossing out dates on a visual calendar in front of your eyes.
Perhaps your working on developing a habit,
like eating broccoli,
and you just have to see all those dates crossed out to keep you motivated.
<samp>cal</samp> will print a calendar,
fine,
but is there some way to mark it?
<p>

<p>
<a href="images/calcurse.png"><img src="thumbs/calcurse.png" title="You can manage your Google Calendar in the terminal"></a>
</p>

<p>
A good ncurses calendar and 2do list program that can do this is <samp>calcurse</samp>.
Besides being a nice looking curses app,
it can export and import to ical formats,
which means that you can use it to manage your Google Calendar.
But surely we can just write a script ourselves that edits the output from <samp>cal</samp>?
You would think that this is a simple task,
but programming is always more complex then we expect
(interactivity more so by orders of magnitude).
But if you really want a script,
here is one suggestion:
</p>

<p>
<pre>
<samp>
#!/bin/sh
# mcal - mark the calendar
# usage: mcal [-f file] [-d month day] [ comments... ]

# set some defaults
file=$HOME/calendar
if [ "$1" = -f ]; then
	file=$2
	shift 2
fi
year=$(date +%Y)
month=$(date +%b | tr A-Z a-z)
day=$(date +%d | sed 's/^0//')
if [ "$1" -d ]; then
	month=$(echo $2 | tr A-Z a-z)
	if (! echo $month | grep -q '^[jfmasond][aepuco][nbrynlgptvc]$'); then
		echo Error: month must be a 3 letter english abbreviation (eg. Jan)
		exit
	fi
	day=$3
	if [ $# = 2 ]; then
		shift 2
	else
		shift 3
	fi
fi
case $month in
	jan) mnr=1 ;;
	feb) mnr=2 ;;
	mar) mnr=3 ;;
	apr) mnr=4 ;;
	may) mnr=5 ;;
	jun) mnr=6 ;;
	jul) mnr=7 ;;
	aug) mnr=8 ;;
	sep) mnr=9 ;;
	oct) mnr=10 ;;
	nov) mnr=11 ;;
	dec) mnr=12 ;;
esac

# no args: print marked calendar
if [ $# = 0 ]; then
	for day in $(awk '/^'$month'/ { print $2 }' $file); do
		mark=-
		if [ $day -gt 9 ]; then
			mark=' -'
		fi
		cat << eof >> /tmp/mcal-ed
g/$day/ \\
s/^$day[^0-9]/ - /\\
s/[^0-9]$day[^0-9]/ $mark /\\
s/[^0-9]$day$/ $mark /
eof
	done
	echo wq >> /tmp/mcal-ed
	cal $mnr $year > /tmp/mcal-cal
	ed -s /tmp/mcal-cal < /tmp/mcal-ed > /dev/null
	cat /tmp/mcal-cal
	rm /tmp/mcal*
	exit
fi

# args: add entry to calendar
printf "%s %s\t" $month $day >> $file
echo "$@" >> $file
</samp>
</pre>
</p>

<p>
Lets ignore the gruesome complexity of this script for now,
and just focus on how to use it:
The script is compatible with <samp>calendar(1)</samp> and <samp>cal(1)</samp>.
With no arguments <samp>mcal</samp> will print the <samp>cal(1)</samp> and replace any dates in your <samp>~/calendar</samp> with a single dash
(so it "crosses out" the marked dates).
If you run <smap>mcal</samp> with some text,
then it will add this as an entry in <samp>~/calendar</samp>,
using todays date by default.
</p>

<p>
So for example,
suppose we add this line to our <samp>~/.bashrc</samp>:
<samp>alias broccoli='mcal -f ~/.broccoli-log'</samp>.
We can then:
</p>

<p>
<pre>
<samp>
$ <i>date</i>
Mon Nov 19 14:02:39 CET 2018
$ <i>broccoli I ate a whole broccoli today, my will is made of steel!</i>
$ <i>broccoli -d nov 18 ate my first vegetable today - I survived!</i>
...
$ <i>date</i>
Tue Nov 20 13:22:04 CET 2018
$ <i>broccoli forced myself to swallow a bite, cant keep this up...</i>
$ <i>broccoli</i>
	November 2018
Su Mo Tu We Th Fr Sa
             1  2  3
 4  5  6  7  8  9 10
11 12 13 14 15 16 17
 -  -  - 21 22 23 24
25 26 27 28 29 30
$ <i>broccoli -d Oct</i>
	October 2018
Su Mo Tu We Th Fr Sa
    1  2  3  4  5  6
 7  8  9 10 11 12 13
14 15 16 17 18 19 20
21 22 23 24 25 26 27
28 29 30 31
$ <i>cat .broccoli-log</i>
nov 19	I ate a whole broccoli today, my will is made of steel!
nov 18	ate my first vegetable today - I survived!
nov 20	forced myself to swallow a bite, cant keep this up...
</samp>
</pre>
</p>

<p>
Why does such as easy task require such a complex script?
Well,
for one the dates needs to work between three programs,
<samp>calendar</samp>,
<samp>cal</samp>
and
<samp>awk</samp>.
The easiest way to create such a compatibility is to force the convention <i>jan 1</i>
for January the first.
The script will automatically convert a user input,
such as <i>Jan</i>,
to lower case.
<i>However</i>,
if you manually write dates in your <samp>~/calendar</samp> file in a different format,
they will not work with <samp>mcal</samp>.
But even with this convention in place,
some conversion is still required as <samp>cal</samp> only understands a month number
(eg. <i>Jan</i> must be <i>1</i>).
</p>

<p>
Secondly,
the process of converting a date,
such as <i>1</i>,
to a dash,
is surprisingly complex.
For example <samp>sed 's/1/-/'</samp>,
will convert this date to a dash,
but it will also convert <i>21</i> to <i>2-</i>,
<i>11</i> to <i>--</i>,
and so on.
So we need to delimit our search:
<samp>sed 's/[^0-9]1[^0-9]/-/'</samp>,
that is:
only convert 1 to a dash if it is preceded and superseded by not-a-number.
However,
this will not mach our number if it is at the beginning or end of a line,
since nothing precedes/supersedes it.
So we need three regex searches to match all cases.
In addition the correct amount of whitespace needs to be added for the columns to line up neatly,
which is somewhat tricky
(in this script we use <samp>ed</samp> rather then <samp>sed</samp>,
since this actually makes things simpler).
</p>

<p>
Note that this script only works for a month at a time,
and it only works for the current year.
Expanding the script to work across multiple months or years is possible,
but complex,
and the script is horrible enough as it is...
If you really wish to mark a yearly calendar,
I suggest you do the following:
<samp>cal 2018 > mycalendar</samp>,
then edit it to your hearts content with your favorite editor,
or go out and buy a paper calendar and a red pen...
I suppose the most useful aspect of this script is that it illustrates how convoluted computer technology can make even trivial tasks.
</p>

<h4 id="password_mng">Password Manager</h4>

<p>
There are a few password managing utilities out there for the console,
but none are really ubiquitous (search your repository for <i>password</i>),
and this is a very simple task to accomplish with a script anyway.
Here is an example that uses GnuPG (it might be called gpg or gpg2 on your system) to manage an encrypted plain text database of passwords:
</p>

<p>
<pre>
<samp>
#!/bin/sh
# pass - a simple password manager
# usage: pass [-de] [ keywords... ]

# set some defaults
gpg=$(which gpg 2>/dev/null) || gpg=$(which gpg2 2>/dev/null) || exit 1
file=${file:-$HOME/.passwords}

# no args: print password file
if [ $# = 0 ]; then
	$gpg --decrypt $file.gpg
	exit
fi

# -d decrypt; -e encrypt; keyword search...
case $1 in
	-d) $gpg --decrypt $file.gpg 1>$file ;;
	-e) $gpg --symmetric $file
	    case $(uname -s) in
		(Linux|SunOS|AIX|CYGWIN*|Haiku)
			(shred $file; rm -f $file) ;;
		(*BSD|DragonFly|Darwin|Minix)
			rm -fP $file ;;
		*) echo "Error: Unknown operating system!"
		   exit 1 ;;
	    esac ;;
	*)  $gpg --decrypt $file.gpg | grep -i "$@" ;;
esac
</samp>
</pre>
</p>

<p>
You can write your passwords in <samp>~/.passwords</samp>,
exactly how is up to you.
Personally,
I write a tab separated database using these fields:
<samp>Category	Name	Username	Password	Email	Website	Comments...</samp>.
But that's just me,
however you choose to write your passwords,
do so in a single line,
and try to be consistent with yourself.
(PS: Some text editors like emacs or vim may leave temporary files around,
you can avoid this problem by configuring your editor not to create such files or you can adjust the script so it <samp>shreds</samp> them too).
You can now search for passwords with <samp>pass searchterm</samp>.
If you later need to add or edit the password database,
run <samp>pass -d</samp>,
edit it with a text editor and run <samp>pass -e</samp> when done.
You can also adjust the script so that the decrypted database is written to memory,
and thus never touches the disk.
But I will leave that as an exercise for the paranoid reader ;)
</p>

<p>
This simple script can be used to automatically authenticate other services,
as an example the following script can be used to search the encrypted database for wireless networks and automatically connect to it:
</p>

<p>
<pre>
<samp>
#!/bin/sh
# con - manage wifi connections
# usage: con name
# depends: pass, wifi

# set some defaults
wlan=${wlan:-wlan0} # change to match your wifi device
tmp=${tmp:/tmp/$$-wifi}
touch $tmp || exit 1
case $(uname -s) in
	(Linux|SunOS|AIX|CYGWIN*|Haiku)
		trap "shred $tmp ; rm -f $tmp" EXIT ;;
	(*BSD|DragonFLY|Darwin|Minix)
		trap "rm -Pf $tmp" EXIT ;;
esac

# query the database (assumes csv file)
pass "$@" > $tmp
matches=$(cat $tmp | wc -l | sed 's/^[ 	]*//')
case $matches in
	0) echo Error, cannot find network! ;;
	1) name=$(awk -F\t '{ print $3 }' $tmp)
	   pass=$(awk -F\t '{ print $4 }' $tmp)
	   sudo wifi $name $pass
	   ;;
	*) awk -F\t '{ print $2, $3, $4 }' $tmp | column -t ;;
esac
</samp>
</pre>
</p>

<p>
This script relies upon the conventions mentioned above, that you store the wifi passwords in a tab separated file encrypted by
<samp>pass</samp>,
and that the 3rd field is the network name, the 4th field the password, and so on.
The script does not handle the details of actually connecting to a wireless device, since that greatly depends upon which system you are using.
Instead it assumes you have a script called
<samp>wifi</samp>,
which knows how to do that given the network name and password as arguments.
Se the
<a href="#wifi">wifi</a>
section above for clues on how to write such a script
(Note: This script also naively assumes that a wireless router needs exactly two arguments,
a name and a password,
and that there is only one type of wireless network,
such as wpa).
</p>
<p>
Finally the
<samp>con</samp>
script,
like the above <samp>pass</samp> script,
has security issues;
it stores the password as plain text in a temporary file while executing.
Although a trap is in place to make sure this file is securely deleted,
this solution is not bullet proof.
If the con process is killed with a SIGKILL signal, the temporary file will remain in place.
There are ways around this, but I leave that as an exercise for the reader.
</p>

<h4 id="accounting">Accounting</h4>

<p>
You can use <samp>ledger</samp> to manage your accounts,
and we already discussed how to make an accounting script yourself with
<a href="#sqlite">sqlite</a>.
But lets explore how to do so with a simple shell script:
</p>

<p>
<pre>
<samp>
#!/bin/sh
# account - basic account manager
# usage: account [-d YYYY-MM-DD][-c catg] [$$.CC [ comments... ]]
# depends: budget

# set some defaults
account=${account:-$HOME/.account}
budget=${budget:-$HOME/.budget}
date=$(date +%Y-%m-%d)
catg=food
for arg in "$@"; do
	case "$arg" in
		-d) date=$2 && shift 2 ;;
		-c) catg=$2 && shift 2 ;;
	esac
done
if (! echo $date | grep -s '^[12][0-9][0-9][0-9]-[01][0-9]'); then
	echo Error: invalid date, use the form YYYY-MM-DD
	exit 1
fi
month=$(echo $date | awk -F- '{ print $2 }')
year=$(echo $date | awk -F- '{ print $1 }')

# no args, print monthly rapport
if [ $# = 0 ]; then
	echo Rapport for $month, $year
	grep "^$year-$month" $account | awk -f $budget
	exit
fi

# with args, add record to account
amount=$1
if (! echo $amount | egrep '^[0-9]+(\.[0-9][0-9])?$')>/dev/null; then
	echo Error: invalid number, use the form 100 or 100.00 with no prefix
	exit 2
fi
shift
if [ ! $catg = income ]; then
	amount=-$amount
fi
echo $date $amount $catg $@ >> $account
</samp>
</pre>
</p>

<p>
This script simply stores account records.
It has no understanding of currency, it just assumes all records are expenses and will convert them to negative integers,
unless the category is
<i>income</i>,
in which case the number remains positive.
The category defaults to
<i>food</i>,
since this is assumed to be your most frequently used expense.
The date is set to your current date by default.
Dates must follow the convention YYYY-MM-DD,
but you can leave out the days if you only want to print a monthly rapport.
</p>

<p>
Monthly rapport you say?
Ah yes, we haven't shown you how to do that yet.
The account script calls an external awk script to produce a rapport of your expenses if you don't supply it with any arguments.
Here is an example of what that script could look like:
</p>

<p>
<pre>
<samp>
BEGIN { printf("%-s\n", "------------------------------") }
/ income/ { income+=$2 }
/ rent/   { rent+=$2 }
/ food/   { food+=$2 }
/ car/    { car+=$2 }
          { sum+=$2 }
END {
printf("%-10s%10.2f %-10s\n", "income:", income, "of 2000")
printf("%-10s%10.2f %-10s\n", "rent:", rent, "of -500")
printf("%-10s%10.2f %-10s\n", "food:", food, "of -500")
printf("%-10s%10.2f %-10s\n", "car:", car, "of -500")
printf("%-10s%10.2f %-10s\n", "misc:", sum - (income + (rent + food + car)), "of -500")
printf("%-s\n", "------------------------------")
printf("%-10s%10.2f\n", "Balance:", sum)
}
</samp>
</pre>
</p>

<p>
Of course I assume your own financial status is somewhat more complex then this,
but the example given should be clear enough so you can expand and adapt it to your needs. 
You could integrate this into the account script so that everything is neatly packed into a single file if you want,
but if your budget changes or more than one person uses account,
it might be better to keep these files separate.
(or you could write a smart piece of code that can interpret a simpler user supplied budget)
Lets demonstrate how to use account:
</p>

<p>
<pre>
<samp>
$ <i>account -d 2018-08-25 -c rent 500</i>
$ <i>account -d 2018-08-25 -c income 2000</i>
$ <i>account -d 2018-08-26 5 starbucks</i>
$ <i>account -c car 254.35</i>
$ <i>account 14.50 groceries</i>
$ <i>account -c cloths 20 jacket</i>
$ <i>account</i>
Rapport for 08, 2018
------------------------------
income:       2000.00 of 2000
rent:         -500.00 of -500
food:          -19.50 of -500
car:          -254.35 of -500
other:         -20.00 of -500
------------------------------
Balance:      1206.15
$ <i>cat .account</i>
2018-08-25 -500 rent
2018-08-25 2000 income
2018-08-26 -5 food starbucks
2018-08-28 -254.35 car
2018-08-28 -14.50 food groceries
2018-08-28 -20 cloths jacket
$ <i>grep '^2018-0[6-8]' .account | awk '/cloths/ { cloths+=$2 } END { print cloths }'</i>
-20
</samp>
</pre>
</p>

<p>
The account script is very basic,
it only supports one single account and has no format support for tags,
but you can use comments for this or you can keep separate accounting databases for different accounts.
For example,
a busy family provider may wish to add this to his <samp>~/.profile</samp>:
</p>
<p>
<pre>
<samp>
alias work="account=$HOME/.workaccount budget=$HOME/.workbudget account"
kids(){
	account "$@" kids
}
wife(){
	account "$@" wife
}
self(){
	account "$@" beer
}
</samp>
</pre>
</p>

<p>
The last line of the previous demonstration also shows how to summarize all expenses used on cloths for June to August 2018,
feel free to play around with awk and gnuplot to mine the database for more useful information.
Since the account database is just plain text it is easy to convert and integrate it into other programs (such as SQL),
for instance you could convert it to csv and open it in LibreOffice: 
<samp>sed -e 's/ /,/' -e 's/ /,/' -e 's/ /,/' .account > account.csv ; localc account.csv</samp>
</p>

<h4 id="addresses">Address book</h4>

<p>
Again, this is stupefyingly easy to just do yourself
(hint: <samp>nano</samp> and <samp>grep</samp> should suffice).
If you really want a dedicated program for this <samp>abook</samp> is a good choice.
</p>


<p>
But lets elaborate.
How would you sync an address book with the contact information in <samp>/etc/passwd</samp>?
Suppose you have a private contact database in <samp>$HOME/.tel</samp>,
which is just a plain text file with the entries <i>"name, address, telephone (work,private), email"</i> per line.
You can create a <samp>tel</samp> command by putting this in <samp>$HOME/.bashrc</samp>:
</p>

<p>
<pre>
<samp>
tel(){ 
	grep "$@" $HOME/.tel 
}
</samp>
</pre>
</p>

<p>
You can now search this database with <samp>tel name</samp>
(or you can search for a number or address or whatever).
Now the following script will read all the user contact information in <samp>/etc/passwd</samp>,
ignore any entries that do not contain email addresses
(emails can be added by the sysadmin in the other (<samp>chfn -o</samp>) category)
and update your local contact database:
</p>

<p>
<pre>
<samp>
#!/bin/sh
# updatetel - update tel db with /etc/passwd entries
# usage: updatetel

tel=${tel:-$HOME/.tel}
IFS='
'
for entry in $(awk -F: '/@/ { print $5 }' /etc/passwd |\
	awk -F, '{ printf("%s\t%s\t%s,%s\t%s\n", $1, $2, $3, $4, $5) }'); do
	name=$(echo $entry | sed 's/	.*//')
	if (grep -q "^$name" $tel); then
		sed -i "s/^$name.*/$entry/" $tel
	else
		echo $entry >> $tel
	fi
done
</samp>
</pre>
</p>

<p>
As long as the employees keep their own contact information correct,
the user can run <samp>updatetel</samp> periodically (eg. once a week with cron),
and all the company contacts should be up to date.
At the same time the user is free to add whatever private contacts he wants to his own database.
And since this database is just a plain text file,
it can be easily synced to his home computer, or phone.
And it would be trivial to convert the data to a spreadsheet or sql database,
or whatever poison consumers may demand nowadays from their suppliers.
</p>

<h4 id="bookmarks">Bookmarks</h4>

<p>
As we have seen, you can read text and pdf files,
listen to music and watch video on the console.
But this involves fiddling about finding the file first,
and worse the program does not usually remember where you left of last time.
Is there a way to bookmark pdf files and videos on the console,
similar to fancy desktop document readers and media players?
Sure! Here is an example script:
</p>

<p>
<pre>
<samp>
#!/bin/sh
# bm - bookmark manager
# usage: [ search... ][ -r file... ][ file page comments... ]

# set some defaults
bm=${bm:-$HOME/.bookmarks}
touch $bm

# parse arguments
if [ "$1" = -r ]; then
	remove=yes && shift
fi
if [ $# = 0 ]; then
	cat $bm && exit
elif [ $# = 1 ]; then
	matches=$(grep "$1" $bm | wc -l)
	if [ $matches = 0 ]; then
		echo No matches found for $1 && exit
	elif [ $matches -gt 1 ]; then
		grep "$1" $bm && exit
	else
		if [ "$remove" = yes ]; then
			file=$(echo $1 | sed 's/\//\\\//g')
			sed -i "/$file/d" $bm; exit
		fi
		file=$(grep "$1" $bm | awk '{ print $1 }')
		page=$(grep "$1" $bm | awk '{ print $2 }')
		if (ps ax | grep X | grep -vq grep); then
			# use these on the desktop
			case $file in
				*.pdf) exec xpdf $file $page ;;
				*.ps) exec gv --page $page $file ;;
				*.?htm?) exec firefox "file://$file#$page" ;;
				(*.avi|*.mp*|*.ogg|*.wav) exec mplayer -ss $page $file ;;
			esac
		else
			# use these on the console
			case $file in
				(*.pdf|*.ps) exec fbgs -fp $page $file ;;
				*.?htm?) exec lynx "file://$file#$page" ;;
				(*.mp3|*.ogg|*.wav) exec mplayer -ss $page $file ;;
				# ps: Linux only, also adjust the resolution if necessary
				(*.avi|*.mp*) exec mplayer -vo fbdev2 -vf scale=1366:768 -ss $page $file ;;
			esac
		fi
		# use these for both desktop and console
		case $file in
			*.t?xt) exec vim +$page $file ;;
			(*.c|*.cpp|Makefile|*.pl|*.rb|*.py|*.php|*.sh) exec vim +$page $file ;;
			(*.el|*.cl|*.lisp|*.sbcl) exec emacs +$page $file ;;
			*) echo I don't know how to open $file && exit ;;
		esac
	fi
fi

# resolve relative/absolute path
if (echo $1 | grep -s '^/'); then
	file=$1
else
	file=$(pwd)/$1
fi
page=$2 # ps: page number is required!
shift 2

# update/add entry in bookmarks
if (awk '{ print $1 }' $bm | grep -q $file); then
	sed -i "s,^.*$file.*$,$file $page $@," $bm
else
	$file $page $@ >> $bm
fi
</samp>
</pre>
</p>

<p>
And a little demonstration of its use:
</p>

<p>
<pre>
<samp>
$ <i>bm Documents/p/plan9/fqa.pdf 177 I wonder if you can have Go in Plan9?</i>
$ <i>bm Documents/a/articles/example.html some_tag something I ment to publish...</i>
$ <i>bm Music/podcast/linuxvoice/lv_s05e17.ogg 1:02:02</i>
$ <i>bm Music/podcast/linuxvoice/lv_s05e18.ogg 30:00</i>
$ <i>bm</i>
/home/dan/Documents/p/plan9/fqa.pdf 177 I wonder if you can have Go in Plan9?
/home/dan/Documents/a/articles/example.html some_tag something I ment to publish...
/home/dan/Music/podcast/linuxvoice/lv_s05e17.ogg 1:02:02
/home/dan/Music/podcast/linuxvoice/lv_s05e18.ogg 30:00
$ <i>bm fqa</i> # open fqa.pdf on page 177 with xpdf
$ <i>bm publish</i> # open example.html at tag "some_tag"
$ <i>bm linuxvoice</i>
/home/dan/Music/podcast/linuxvoice/lv_s05e17.ogg 1:02:02
/home/dan/Music/podcast/linuxvoice/lv_s05e18.ogg 30:00
$ <i>bm lv_s05e18</i> # start playing lv_s05e18.ogg 30 minutes into the audio file
$ <i>bm Music/podcast/linuxvoice/lv_s05e18.ogg 45:00</i>
$ <i>bm -r lv_s05e17</i>
$ <i>bm -r example</i>
$ <i>bm</i>
/home/dan/Documents/p/plan9/fqa.pdf 177 I wonder if you can have Go in Plan9?
/home/dan/Music/podcast/linuxvoice/lv_s05e18.ogg 45:00
</samp>
</pre>
</p>

<p>
This script contains some Kong Fu ASCII Puke,
<samp>sed 's/\//\\\//g'</samp> is particularly jarring.
Nevertheless it should be fairly simple to edit the script and adjust your favorite application to their file types.
Also note that this script requires you to add a page number
(if it's an audio/video file the "page" is the time you stopped playing),
if you only want to find a file,
use <samp>locate</samp> or <samp>find</samp> instead.
In theory you could add support for online bookmarking and other things,
if you feel hackish (the provided html support assumes a local html file).
</p>

<p>
Some modification tips:
First of all only Linux can play video files in the framebuffer,
but you probably need to adjust the resolution and set things up
(see the
<a href="#framebuffer">framebuffer</a> section).
You may also wish to change some of the default programs,
eg. vim to <samp>nano</samp> or <samp>less</samp>, both use the <samp>+linenr</samp> syntax
(you might want to take a chance and just use vim or less if a file prefix wasn't recognized).
You can also change both the pdf and ps viewer to <samp>okular --page</samp> or <samp>evince --page-index</samp>,
or a different pdf reader,
but be aware that not all viewers support this feature.
Finally,
you could use <samp>vlc --start-time</samp> instead of mplayer,
but be aware that vlc only supports start time in seconds.
You cannot type <samp>vlc --start-time 10:00</samp>, you must instead use <samp>--start-time 600</samp>.
Of course you could always edit <samp>bm</samp> so that it converts such time formats to seconds,
but I leave that as an exercise for the reader.
</p>

</p>

<h4 id="timetracker">Keeping Track of Time</h4>

<p>
You can easily check what the time is with <samp>date</samp>.
Or if you prefer to keep a digital clock around,
you can use <samp>tty_clock</samp>.
And naturally <samp>tmux</samp> comes preconfigured with a digital clock in the lower right corner.
If you need to schedule some task at a particular time,
commands such as <samp>at</samp>, <samp>cron</samp> and <samp>anacron</samp> can help;
if you need to run a one time command,
run a server command regularly,
or run a laptop command regularly,
respectably.
</p>

<p>
The <samp>time</samp> command is primarily used to measure how much time a program uses before it exits.
But you can use it to measure yourself.
Just type <samp>time read</samp>,
and hit <kbd>Ctrl</kbd> + <kbd>d</kbd> (this key combo means "end of file") when done.
<samp>time</samp> prints three numbers;
<samp>sys</samp>tem time, relevant for kernel hackers.
<samp>user</samp> time, relevant for hackers.
And <samp>real</samp> time, relevant for people.
</p>

<p>
Perhaps you need a more elaborate time keeping program though,
to measure how much time you spend on various projects.
Here is one example:
</p>

<p>
<pre>
<samp>
#!/bin/sh
# track - keep track of time
# usage: [[-r][-s][ start|stop ] project comments... ]

dir=${dir:-$HOME/.track}
mkdir -p $dir
output=${output:-60} # ei. output in minutes

if [ $# = 0 ]; then
	for file in $(ls $dir | grep -v ongoing); do
		if [ -f $dir/${file}_ongoing ]; then
			echo $file '(ongoing)'
		else
			echo $file
		fi
	done
elif [ $# = 1 ]; then
	cat $dir/$1
elif [ $1 = -r ]; then
	# remove file
	rm $dir/$2
elif [ $1 = -s ]; then
	# summarize time used on this project
	awk '{ sum+=$2 } END { print sum }' $dir/$2
elif [ $1 = start ]; then
	date "+%s" > $dir/${2}_ongoing
elif [ $1 = stop ]; then
	file=$2
	shift 2
	start=$(cat $dir/${2}_ongoing)
	rm $dir/${2}_ongoing
	stop=$(date "+%s")
	time=$(echo "scale=2; ($stop - $start) / $output" | bc)
	echo $(date "+%Y-%m-%d") $time "$@" >> $dir/$file
fi
</samp>
</pre>
</p>

<p>
You can then use it like so:
</p>

<p>
<pre>
<samp>
$ <i>track start work</i>
$ <i>track start solitaire</i>
$ <i>track stop solitaire all work and no play makes jack a dull boy</i>
$ <i>track</i>
  work (ongoing)
  solitaire
$ <i>track solitaire</i>
2018-04-26 5.02 all work and no play makes jack a dull boy
$ <i>track -s solitaire</i>
5.02
</samp>
</pre>
</p>

<p>
Again, this script is fanatically simplistic.
In particular it's perception of time is very naive.
It reports time used in minutes with two decimal points,
so 1 hour, 11 minutes and 12 seconds,
will be reported as: 71.20.
This stupidity is somewhat ironic since the purpose of this program is to help you keep accurate track of time...
</p>

<p>
You can modify the output to show a more human readable time format with yet another script, for example:
</p>

<p>
<pre>
<samp>
$ <i>humantime(){</i>
> <i>seconds=${1#*.}</i>
> <i>seconds=$(echo "($seconds * 60) / 100" | bc)</i>
> <i>minutes=${1%.*}</i>
> <i>hours=$(echo $minutes / 60 | bc)</i>
> <i>minutes=$(echo "$minutes - ($hours * 60)" | bc)</i>
> <i>echo $hours hours, $minutes minutes and $seconds seconds</i>
> }
$ <i>humantime $(track -s solitaire)</i>
0 hours, 5 minutes and 1 seconds
</samp>
</pre>
</p>

<p>
Why isn't this functionality included in the script?
After careful consideration I chose not to add it for a couple of reasons:
First of all the simplistic format makes it very easy to use the tracking data with external programs,
such as drawing a graph with <samp>gnuplot</samp>.
Or you can easily generate reports with it in <samp>awk</samp>,
calculating percentages,
and even merge or split tasks if you need to.
Such tasks would be massively more complex if <samp>track</samp> reported time as "1 hour, 11 minutes and 12 seconds".
</p>

<p>
Secondly and most importantly, I wanted to write a simple example.
Handling time correctly is anything but simple.
Suppose you wanted to write it in the format HH:MM:SS,
how would you make sure the minutes are exactly two digits
(eg. "02" not "2" minutes)?
What about the hours?
Suppose a project has taken 300 hours,
should you split those into days?
Of what length, should you use a literal 24 hour day or an 8 hour work day.
If you use 8 hour work days, should you skip weekends and holidays?
Do you begin to see the problem..?
And thus,
I lazily give you this crude script,
and leave it as an exercise to you dear reader,
to extend it to something thats actually useful ;)
</p>

<h2 id="x11">Console and X11 Integration</h2>

<p>
The purpose of this howto is explain how to use the console as a desktop,
so why are we talking about X11 (the graphical desktop on UNIX)?
Well,
realistically you may need to dip your toes into a graphical desktop once in a while.
Don't be ashamed,
even Stallman uses a desktop sometimes...
Sadly though there is little convergence between the UNIX console and its desktop,
the reason being that the desktop was created later,
and without much though to existing design philosophy.
Is it possible then to integrate these two worlds,
and thus create an effective working environment also on the desktop..?
</p>

<h3 id="retrieving">Retrieving Console Data</h3>

<p>
The easiest way to move data between the console and the desktop is simply to redirect output to files.
For instance say you wanted to import the output of <samp>ps ax</samp> to LibreOffice,
you could do this:
</p>

<p>
<pre>
<samp>
$ <i>ps ax | sed 's/^  *//' | sed -e 's/  */,/' -e 's/  */,/' -e 's/  */,/' -e 's/  */,/' > ps.csv</i>
$ <i>localc ps.csv</i>
</samp>
</pre>
</p>

<p>
This simple but cumbersome sed line converts the first four spaces to commas (there's two spaces in 's/  */,/'),
this transforms the data into a comma separated file,
which can be opened nicely in LibreOffice Calc
(or <samp>localc</samp>).
This example illustrates that it is sometimes necessary to transform the text a bit before you can feed it other programs,
especially programs that don't follow normal UNIX conventions.
Tools such as <samp>sed</samp>, <samp>tr</samp>, <samp>fmt</samp>, not to mention <samp>awk</samp>,
are essential for such tasks.
</p>

<p>
Redirecting text from a graphical program to a file can be more tricky though.
The X11 desktop actually has two clipboards,
the classic xclipboard works by first selecting text with left-click and drag,
then middle click where you want to paste it.
The marked text is automatically copied into the xclipboard,
so you don't need to do a manual copy action.
The command line tool <samp>xclip</samp> can be used to manipulate xclipboards.
For instance you can find a nice Youtube video in Firefox,
mark the URL (Ctrl-L),
then type <samp>youtube-dl $(xclip -o)</samp> in a terminal to download it
(of course you could also have typed youtube-dl and middle clicked).
</p>
<p>
The newer X selections,
on the other hand,
tries to mimic Microsoft Windows,
where you first mark the text,
then right-click and select copy,
then right-click and select paste
(you can also use keyboard shortcuts for this).
The command line tool for manipulating these X selections is <samp>xsel</samp>.
</p>
<p>
In addition <samp>tmux</samp> has quite advanced clipboard management that can be integrated with X11 in various ways.
Look into it if your interested :)
</p>

<p>
Sometimes you need to move a process,
say from the console to a terminal running in the desktop
(or vice versa).
<samp>reptyr</samp> is your friend
(Linux and FreeBSD only).
Another example of its usefulness:
Say its late at the office and you want to go home,
but you started a long running process over SSH that cannot be interrupted,
and you forgot to run <a href="#tmux"><samp>tmux</samp></a> first.
What do you do?
Log in to the server again,
run <samp>tmux</samp>,
then use <samp>reptyr</samp> to move the process over to <samp>tmux</samp>,
you can now kill the ssh session and head on home,
the process will continue to run in the detached tmux session.
</p>

<h3 id="screencapture">Screen Capturing The Console</h3>

<p>
If you have framebuffer support (Linux only) you can use <samp>fbcat</samp> or <samp>fbgrab</samp> to take a screenshot of your console,
and <samp>ffmpeg</samp> can be used to optain a full video screencapture of your console:
</p>

<p>
<ul>
  <li><samp>ffmpeg -f fbdev -framerate 25 -i /dev/fb0 output.mp4</samp>, screencapture the raw console</li>
  <li><samp>ffmpeg -f x11grab -y -r 30 -s 1920x1080 -i 0:0 -vcodec huffyuv out.avi</samp>, screencapture the desktop from console/terminal</li>
  <li><samp>ffmpeg -video_size 1024x768 -framerate 25 -f x11grab -i :0.0+100,200 -f alsa -ac 2 -i hw:0 output.mkv</samp>, screencast with audio using alsa</li>
  <li><samp>ffmpeg -video_size 1024x768 -framerate 25 -f x11grab -i :0.0+100,200 -f pulse -ac 2 -i default output.mkv</samp>, screencast with audio using pulseaudio</li>
</ul>
</p>

<p>
The last two examples are for desktop recording,
but you should be able to tweak them in order to record the framebuffer console
(hint use <i>-f fbdev</i> instead of <i>-f x11grab</i>).
These last examples is very hardware demanding though,
and will likely produce a bad result,
a simple workaround is to capture a smaller resolution.
Either set a smaller desktop resolution,
or capturing a smaller nested X desktop (see <i>Xephyr</i>),
or just record a corner of your desktop.
</p>

<p>
For recording plain text you can use <samp>ttyrec</samp> or the venerable old tool <samp>script</samp>,
note however that <samp>script</samp> will not work well with interactive applications,
such as <samp>vi</samp>.
If you need to record text editing,
either use <samp>ed</samp> or record your <samp>vi</samp> sessions with <samp>ttyrec</samp>.
</p>

<h3 id="console_desktop">Putting a Console on the Desktop</h3>

<p>
The reason working on the console is so efficient,
is not because it lacks graphics per say,
but rather that its a text oriented,
distraction free environment.
Can you create such an environment in X11?
</p>

<p>
Yes.
Tiling window managers are the answer.
These work essentially as <samp>tmux</samp> or <samp>screen</samp> on the console,
and there are a great many to choose from.
I would personally recommend <samp>dwm</samp>,
its lightweight,
easy to use and has all the features you will likely need.
Just get it and read the manpage.
</p>

<p>
In addition you can replace some graphical applications,
and desktop features,
with alternatives that are keyboard friendly,
and have minimal interfaces.
Some suggestions:
</p>
<p>
<ul>
  <li>mupdf - PDF reader</li>
  <li>mplayer (or mpv) - Video and Music player</li>
  <li>surf (or vimperator in firefox) - Web browser</li>
  <li>feh - Image viewer</li>
  <li>uxterm - Terminal emulator</li>
  <li>xrandr - Manage multiple screens and different resolutions</li>
  <li>keynav - Do mouse actions with the keyboard (Linux only)</li>
  <li>xscreensaver - Screensaver and locker</li>
  <li>scrot - Take a screenshot</li>
  <li>dmenu - Searchable menu, integrated in dwm and other wm's</li>
</ul>
</p>
<p>
Naturally you can also use all the console applications mentioned here in an X11 terminal.
Most of these are available for the BSD's as well as Linux.
As for Solaris,
a lot less software is available in the repository by default,
and to be sure,
compiling Linux software in Solaris will give you all kinds of pain.
Despite the woes however,
many of software mentioned in this article will be available.
A pro tip:
The NetBSD ports collection,
pkgsrc,
is designed to work on many different operating systems,
including Solaris.
</p>

<p>
<a href="https://pspodcasting.net/images/dan/blog/2018/dwm.png"><img src="thumbs/dwm.png" title="Desktops can be terminal friendly"></a>
</p>

<h3 id="desktop_console">Putting a Desktop on the Console</h3>

<p>
We have now talked a bit about moving the console into your desktop,
but is it possible to do it the other way around?
There are at least two options available for Linux.
<samp>twin</samp> is a simple stacking window manager for the console using ncurses graphics,
you can create new terminal windows from its drop down menu,
resize windows and move them about with your mouse.
Not very useful in my humble opinion,
but cool non the less.
</p>

<p>
<a href="https://pspodcasting.net/images/dan/blog/2018/twin.png"><img src="thumbs/twin.png" title="The ncurses twin Window Manager"></a>
</p>

<p>
Speaking of not-so-useful-but-cool,
the libCACA team has created an experimental fork of <samp>screen</samp> called <samp>neercs</samp>
(that is screen spelled backwards).
It works much like <samp>screen</samp>,
but has some ridiculous extended features,
such as an ASCII 3D spinning desktop cube...
You will probably not find it in the repo,
but you can get it like so:
<samp>git clone git://git.zoy.org/neercs.git</samp>
(PS: This program is buggy, slow and unmaintained.
Like Compiz, I would not recommend it for daily use,
but its fun to keep around in case you want to knock the socks of some unsuspecting Windows user...)
</p>

<p>
<a href="https://pspodcasting.net/images/dan/blog/2018/neercs.png"><img src="thumbs/neercs.png" title="neercs is screen - with visual effects!"></a>
</p>

<h2 id="conclusion">Conclusion</h2>

<p>
	Most Linux users are vaguely aware that the console exists,
	and many sysadmins use it daily to administrate their servers,
	but as we have seen in this article the console can work reasonably well as an everyday desktop.
	Tasks such as basic
	<a href="#browsing">HTML browsing</a>,
	<a href="#email">email</a> and
	<a href="#chatting">chatting</a> works very well in the console.
	As does
	<a href="#music">playing music</a>
	and text
	<a href="#game">games</a>.
	Lastly,
	office tasks such as
	<a href="#writing">writing documents</a>,
	using
	<a href="#spreadsheets">spreadsheets</a>
	and doing
	<a href="#pim">PIM</a>
	related tasks is easy.
	On a Linux console with a
	<a href="#framebuffer">graphical framebuffer</a>
	enabled,
	you can even view
	<a href="#pictures">pictures</a>,
	<a href="#pdf">pdf's</a>,
	<a href="#video">videos</a>
	and play
	<a href="#framebuffer_games">graphical games</a>!
</p>

<p>
	There are limitations though.
	Obviously graphic heavy tasks,
	such as triple A games and 3D movie production,
	is not well suited for the humble text console.
	The most painful limitation of all is the lack of a modern web browser.
	Realistically this limitation cannot be solved,
	creating a text browser capable of rendering pages as well as Google Chrome,
	would literally require more effort then recreating the Linux operating system from scratch!
	Nevertheless,
	dipping your toes into the console,
	and learning how to use it efficiently,
	can greatly boost your productivity.
	These skills are absolutely useful to have,
	even on
	<a href="#console_desktop">the desktop</a>!
</p>

<p>
	Most of all,
	it's great fun :)
</p>

<p>
<a href="images/fun.png"><img src="thumbs/fun.png" title="Have Fun!"></a>
</p>

</body>
</html>
(F      aaCJa   j    O^partitionKey=%28https%2Cpspodcasting.net%29,:https://pspodcasting.net/dan/blog/2018/console_desktop.html strongly-framed 1 security-info FnhllAKWRHGAlo+ESXykKAAAAAAAAAAAwAAAAAAAAEaphjojH6pBabDSgSnsfLHeAAAAAgAAAAAAAAAAAAAAAAAAAAEANgFmCjImkVxP+7sgiYWmMt8FvcOXmlQiTNWFiWlrbpbqgwAAAAAAAAYqMIIGJjCCBQ6gAwIBAgISBJoNem5EAfjKFKfVTxZv6SSDMA0GCSqGSIb3DQEBCwUAMDIxCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1MZXQncyBFbmNyeXB0MQswCQYDVQQDEwJSMzAeFw0yMTA3MDMxNzAyMjdaFw0yMTEwMDExNzAyMjZaMBsxGTAXBgNVBAMTEHBzcG9kY2FzdGluZy5uZXQwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCoVytxjvw0lKTz7+Wfump7C7cSMvUB+SlG6rgsoJy1AsaJEekkRogVCvjlwOY4/iEkMl9vH/V8V+/IkaLO4moFd332atoac1W31vRNrJw8W4GzGorFi//joT1tLjjKiEWEA4J2M1Vu4ZVzZS92gTNeH3HgRG3M1QigiMiWqWJvpIHG2IA3IpJnVYSmXY1+mppDGPhfscJ3nTnV/OooakZ4ThrrxTi46Z2cxvyHhE9NuMoKplPPb+Zjt+MKFJX+FgEDqg9I72LiE7OzFdDq7aE/7QBhNf7JsGojIB8my335veUmh61IUdvLuAdKm3kvRo0MWXo82i3vn7JR8D79IxXHabU99/qjjwkerMubpZUkWdr1DBUo7U0/i0kLYdtmSlC74rsq7/wVmyj34im5w2FcfmoXQ7pWqCK5UMuXZ88kC+hr3vwgJnfF8QNpt4ZwxFG+zkhcpAja1p9S2Ivr/L8krRaIQaHHrf8LQFKR9GYFulYsjUc8PDELZVmMNAddGsTLLnE/CLpfcm4zAAz4x7ARTmtfNeNE6e24Q2FR59Sqn2/HfEDLRMfPd6NtmNogSJZmlGi8hW93iM3ALZ5mF2xR9Ru7vSAWfpw0CeELlqs8RCQmEV1OumjdJibxLIc3hm7qW7K5md23oc9TlBWU7jY4ABarw73+TsSlQ9wIriAFiwIDAQABo4ICSzCCAkcwDgYDVR0PAQH/BAQDAgWgMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAMBgNVHRMBAf8EAjAAMB0GA1UdDgQWBBQ0Ik48NdLTFK35S2AoPOmHXBJsxTAfBgNVHSMEGDAWgBQULrMXt1hWy65QCUDmH6+dixTCxjBVBggrBgEFBQcBAQRJMEcwIQYIKwYBBQUHMAGGFWh0dHA6Ly9yMy5vLmxlbmNyLm9yZzAiBggrBgEFBQcwAoYWaHR0cDovL3IzLmkubGVuY3Iub3JnLzAbBgNVHREEFDASghBwc3BvZGNhc3RpbmcubmV0MEwGA1UdIARFMEMwCAYGZ4EMAQIBMDcGCysGAQQBgt8TAQEBMCgwJgYIKwYBBQUHAgEWGmh0dHA6Ly9jcHMubGV0c2VuY3J5cHQub3JnMIIBBAYKKwYBBAHWeQIEAgSB9QSB8gDwAHcAXNxDkv7mq0VEsV6a1FbmEDf71fpH3KFzlLJe5vbHDsoAAAF6bYk59wAABAMASDBGAiEAqz5Lmo6DL7izrQmFIEJP9zAzcMnvcTrw4PSbGhZ9CokCIQDeBHVq6Li6f5NfCoVqH6PMJEQLlidtdfrqYt8oY94OmQB1APZclC/RdzAiFFQYCDCUVo7jTRMZM7/fDC8gC8xO8WTjAAABem2JOfMAAAQDAEYwRAIgPzwnJhZovwHrF/cftNQJRAgFB2MWGf6kh7p5O8yasl8CIEFBzVE69hhQtx3XpfeilrDpd/vNh2s2+vGSCYp+GN6nMA0GCSqGSIb3DQEBCwUAA4IBAQAXlKRtR/J0RWCdtOyFOI0nAtZMuEwx9i5r8N6pARpxG7ZXBe4lSgsBEor6GHtX+CgSz4eiv+T/8VpkuNGuUJMXiVCdIvxpLN691gukhjsya0uHBTNkiVaLYO+wrcqBizNTieZZpLKkdqjmyfqk9UmCzwTsXE9sxY9GJWvDqEuehQeSTdnl8dUIKavT44Tf01pfJN3xotMpJxiBDcaDTtvJ9OUWl94JbOQXgz+ScA4So10BgUtblACenEBPtEbpgU/0+vd40Ug5+Ca7WrbgoFI/IONr7G4bOzwh0kCFsxDBgwJL3drnZuMfoY+39d+g94Il+pbHd4SjVICividS+hlLEwEABAAAAAABAQAAAAAAAAZ4MjU1MTkAAAAOUlNBLVBTUy1TSEEyNTYAA2YKMiaRXE/7uyCJhaYy3wW9w5eaVCJM1YWJaWtuluqDAAAAAAAABiowggYmMIIFDqADAgECAhIEmg16bkQB+MoUp9VPFm/pJIMwDQYJKoZIhvcNAQELBQAwMjELMAkGA1UEBhMCVVMxFjAUBgNVBAoTDUxldCdzIEVuY3J5cHQxCzAJBgNVBAMTAlIzMB4XDTIxMDcwMzE3MDIyN1oXDTIxMTAwMTE3MDIyNlowGzEZMBcGA1UEAxMQcHNwb2RjYXN0aW5nLm5ldDCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAKhXK3GO/DSUpPPv5Z+6ansLtxIy9QH5KUbquCygnLUCxokR6SRGiBUK+OXA5jj+ISQyX28f9XxX78iRos7iagV3ffZq2hpzVbfW9E2snDxbgbMaisWL/+OhPW0uOMqIRYQDgnYzVW7hlXNlL3aBM14fceBEbczVCKCIyJapYm+kgcbYgDcikmdVhKZdjX6amkMY+F+xwnedOdX86ihqRnhOGuvFOLjpnZzG/IeET024ygqmU89v5mO34woUlf4WAQOqD0jvYuITs7MV0OrtoT/tAGE1/smwaiMgHybLffm95SaHrUhR28u4B0qbeS9GjQxZejzaLe+fslHwPv0jFcdptT33+qOPCR6sy5ullSRZ2vUMFSjtTT+LSQth22ZKULviuyrv/BWbKPfiKbnDYVx+ahdDulaoIrlQy5dnzyQL6Gve/CAmd8XxA2m3hnDEUb7OSFykCNrWn1LYi+v8vyStFohBocet/wtAUpH0ZgW6ViyNRzw8MQtlWYw0B10axMsucT8Iul9ybjMADPjHsBFOa18140Tp7bhDYVHn1Kqfb8d8QMtEx893o22Y2iBIlmaUaLyFb3eIzcAtnmYXbFH1G7u9IBZ+nDQJ4QuWqzxEJCYRXU66aN0mJvEshzeGbupbsrmZ3behz1OUFZTuNjgAFqvDvf5OxKVD3AiuIAWLAgMBAAGjggJLMIICRzAOBgNVHQ8BAf8EBAMCBaAwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMAwGA1UdEwEB/wQCMAAwHQYDVR0OBBYEFDQiTjw10tMUrflLYCg86YdcEmzFMB8GA1UdIwQYMBaAFBQusxe3WFbLrlAJQOYfr52LFMLGMFUGCCsGAQUFBwEBBEkwRzAhBggrBgEFBQcwAYYVaHR0cDovL3IzLm8ubGVuY3Iub3JnMCIGCCsGAQUFBzAChhZodHRwOi8vcjMuaS5sZW5jci5vcmcvMBsGA1UdEQQUMBKCEHBzcG9kY2FzdGluZy5uZXQwTAYDVR0gBEUwQzAIBgZngQwBAgEwNwYLKwYBBAGC3xMBAQEwKDAmBggrBgEFBQcCARYaaHR0cDovL2Nwcy5sZXRzZW5jcnlwdC5vcmcwggEEBgorBgEEAdZ5AgQCBIH1BIHyAPAAdwBc3EOS/uarRUSxXprUVuYQN/vV+kfcoXOUsl7m9scOygAAAXptiTn3AAAEAwBIMEYCIQCrPkuajoMvuLOtCYUgQk/3MDNwye9xOvDg9JsaFn0KiQIhAN4EdWrouLp/k18KhWofo8wkRAuWJ211+upi3yhj3g6ZAHUA9lyUL9F3MCIUVBgIMJRWjuNNExkzv98MLyALzE7xZOMAAAF6bYk58wAABAMARjBEAiA/PCcmFmi/AesX9x+01AlECAUHYxYZ/qSHunk7zJqyXwIgQUHNUTr2GFC3Hdel96KWsOl3+82Hazb68ZIJin4Y3qcwDQYJKoZIhvcNAQELBQADggEBABeUpG1H8nRFYJ207IU4jScC1ky4TDH2Lmvw3qkBGnEbtlcF7iVKCwESivoYe1f4KBLPh6K/5P/xWmS40a5QkxeJUJ0i/Gks3r3WC6SGOzJrS4cFM2SJVotg77CtyoGLM1OJ5lmksqR2qObJ+qT1SYLPBOxcT2zFj0Yla8OoS56FB5JN2eXx1Qgpq9PjhN/TWl8k3fGi0yknGIENxoNO28n05RaX3gls5BeDP5JwDhKjXQGBS1uUAJ6cQE+0RumBT/T693jRSDn4JrtatuCgUj8g42vsbhs7PCHSQIWzEMGDAkvd2udm4x+hj7f136D3giX6lsd3hKNUgKK+J1L6GUtmCjImkVxP+7sgiYWmMt8FvcOXmlQiTNWFiWlrbpbqgwAAAAAAAARpMIIEZTCCA02gAwIBAgIQQAF1BIMUpMghjISpDBbN3zANBgkqhkiG9w0BAQsFADA/MSQwIgYDVQQKExtEaWdpdGFsIFNpZ25hdHVyZSBUcnVzdCBDby4xFzAVBgNVBAMTDkRTVCBSb290IENBIFgzMB4XDTIwMTAwNzE5MjE0MFoXDTIxMDkyOTE5MjE0MFowMjELMAkGA1UEBhMCVVMxFjAUBgNVBAoTDUxldCdzIEVuY3J5cHQxCzAJBgNVBAMTAlIzMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAuwIVKMz2oJTTDxLsjVWSw/iC8ZmmekKIp10mqrUrucVMsa+Oa/l1yKPXD0eUFFU1V4yeqKI5GfWCPEKpTm71O8Mu243AsFzzWTjn7c9p8FoLG77AlCQlh/o3cbMT5xys4Zvv2+Q7RVJFlqnBU840yFLuta7tj95gcOKlVKu2bQ6XpUA0ayvTvGbrZjR8+muLj1cpmfgwF126cm/7gcWt0oZYPRfH5wm78Sv3htzB2nFd1EbjzK0lwYi8YGd1ZrPxGPeiXOZT/zqItkel/xMY6pgJdz+dU/nPAeX1pnAXFK9jpP+Zs5Od3FOnBv5IhR2haa4ldbsTzFID9e1RoYvbFQIDAQABo4IBaDCCAWQwEgYDVR0TAQH/BAgwBgEB/wIBADAOBgNVHQ8BAf8EBAMCAYYwSwYIKwYBBQUHAQEEPzA9MDsGCCsGAQUFBzAChi9odHRwOi8vYXBwcy5pZGVudHJ1c3QuY29tL3Jvb3RzL2RzdHJvb3RjYXgzLnA3YzAfBgNVHSMEGDAWgBTEp7Gkeyxx+tvhS5B1/8QVYIWJEDBUBgNVHSAETTBLMAgGBmeBDAECATA/BgsrBgEEAYLfEwEBATAwMC4GCCsGAQUFBwIBFiJodHRwOi8vY3BzLnJvb3QteDEubGV0c2VuY3J5cHQub3JnMDwGA1UdHwQ1MDMwMaAvoC2GK2h0dHA6Ly9jcmwuaWRlbnRydXN0LmNvbS9EU1RST09UQ0FYM0NSTC5jcmwwHQYDVR0OBBYEFBQusxe3WFbLrlAJQOYfr52LFMLGMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjANBgkqhkiG9w0BAQsFAAOCAQEA2UzgyfWEiDcx27sT4rP8i2tiEmxYt0l+PAK3qB8oYevO4C5z70kHejWEHx2taPDY/laBL21/WKZuNTYQHHPD5b1tXgHXbnL7KqC401dk5VvCadTQsvd8S8MXjohyc9z9/G2948kLjmE6Flh9dDYrVYA9x2O+hEPGOaEOa1eePynBgPayvUfLqjBstzLhWVQLGAkXXmNs+5ZnPBxzDJOLxhF2JIbeQAcH5H0tZrUlo5ZYyOqA7s9pO5b85o3AM/OJ+CktFBQtfvBhcJVd9wvlwPsk+uyOy2HI7mNxKKgsBTt375teA2TwUdHkhVNcsAKX1H7GNNLOEADksd86wuoXvmYKMiaRXE/7uyCJhaYy3wW9w5eaVCJM1YWJaWtuluqDAAAAAAAAA04wggNKMIICMqADAgECAhBEr7CA1qMnuokwOYYu+EBrMA0GCSqGSIb3DQEBBQUAMD8xJDAiBgNVBAoTG0RpZ2l0YWwgU2lnbmF0dXJlIFRydXN0IENvLjEXMBUGA1UEAxMORFNUIFJvb3QgQ0EgWDMwHhcNMDAwOTMwMjExMjE5WhcNMjEwOTMwMTQwMTE1WjA/MSQwIgYDVQQKExtEaWdpdGFsIFNpZ25hdHVyZSBUcnVzdCBDby4xFzAVBgNVBAMTDkRTVCBSb290IENBIFgzMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA36/pl1AIg1e0zGJl9pCC7MfTLGswylvs2cN9x0DBGBSL4Ogzdkkq4z8hSZOsTg6vPkjLZe780yEPZdIq2TKPjOX3d7ASe7WVwImjqbrtcy56DAYyg6J+ihQwzRGg4So4uXkKMf1QvYBl37dRY4PI4ohh6kthgexSa7mi4ksaKJ9Io54M2gmOPhcuHt0g31vGKoqrLr1wrcULGiWQdHLFe2qrNNYwif/laBN7VAvI1q7sWpySHj1ks4zG37/JQXDsFnLVJuw4VTlD0Pz9GFxA8Zfr1ZqbjR262iW5xtjfwRUCOqvabvE+LvVcCJw81oNp5BCbGSq2KVfj5T2bn/ACXQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIBBjAdBgNVHQ4EFgQUxKexpHsscfrb4UuQdf/EFWCFiRAwDQYJKoZIhvcNAQEFBQADggEBAKMaLJsXAFypHu4oZjc6v4PHP0vDCaCVIF3j2VlE0j4NPr2KS6B0H84Qgpx0Gh1+mBrdyxNLsyBE5JHpzPx9pdtq5f7m/eBO3bcAOrVwSa/y5esC8dECixnLlDpeSMQYHlgZXx4CWvAM8bGtqdxZhotu6ZH1hsr6uWYzqllbzuKnFnNHyyvMmbA3SM/jVkv1zw8McjKHxvBEu1NybUP1JkiaUme3WKv+Z3ZxeNsNolYUEzkkMYWiqAJaMEfh3VAHvAIJkADrZGNgmxa8iMkS5tJ9kYv5PTKNZbTpfLFXdurFtig5vxVlHMj2d5ZqCo13C9iRCwSOB9sptgrunYI1NRAAAAABAAAAAmgyAAEA request-method GET response-head HTTP/2 200 OK
server: nginx/1.21.1
date: Thu, 12 Aug 2021 06:29:46 GMT
content-type: text/html
content-length: 250040
last-modified: Sun, 27 Jun 2021 18:49:23 GMT
etag: "60d8c833-3d0b8"
accept-ranges: bytes
strict-transport-security: max-age=31536000
X-Firefox-Spdy: h2
 original-response-headers server: nginx/1.21.1
date: Thu, 12 Aug 2021 06:29:46 GMT
content-type: text/html
content-length: 250040
last-modified: Sun, 27 Jun 2021 18:49:23 GMT
etag: "60d8c833-3d0b8"
accept-ranges: bytes
strict-transport-security: max-age=31536000
X-Firefox-Spdy: h2
 ctid 1 uncompressed-len 0 net-response-time-onstart 45740 net-response-time-onstop 47016  